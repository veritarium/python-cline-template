Punkt 1: Zielbild und Spielregeln festlegen
Ziel dieses Punkts: Du definierst ein kleines „Arbeitsabkommen“ (Project Contract), das für dich und Cline gilt. Damit werden Aufgaben klarer, Ergebnisse stabiler, und du verhinderst typische Agent‑Fehler (Neben‑Refactors, ungetestete Änderungen, neue Dependencies ohne Absprache, falsche venv).

Du kannst das in 10–20 Zeilen in dein Repo schreiben (z. B. in DEVELOPMENT.md) und später zusätzlich als .clinerules “hart” machen.

1.1 Definition of Done (DoD) festlegen
Schreibe in DEVELOPMENT.md (oder ganz oben in deiner Taskbeschreibung) eine DoD, die immer gilt.

Copy/Paste‑Block (DoD):

## Definition of Done (DoD)

Eine Aufgabe ist "fertig", wenn:

- Das definierte Verhalten ist implementiert (Akzeptanzkriterien erfüllt).
- Das Quality Gate ist grün:
  - .\scripts\check.ps1
- Neue/ändernde Logik hat Tests:
  - Feature: mind. 1 Test pro neuem Verhalten
  - Bugfix: Regression-Test, der vorher fehlschlägt
- Keine Neben-Refactors (nur Änderungen, die zur Aufgabe gehören).
- Keine neuen Dependencies ohne explizite Freigabe.
- Änderungen sind in kleinen, nachvollziehbaren Commits geschnitten.
Wenn du (noch) kein scripts/check.ps1 hast, ersetze die Zeile durch deine direkten Commands (ruff/pytest). Das Skript kommt in Punkt 7.

1.2 Quality Gate definieren (die 2–4 Checks, die immer gelten)
Wähle bewusst: Minimal oder Pro. Hauptsache: konsistent.

Minimal (sehr gut für die meisten Projekte):

Ruff Lint

Ruff Format Check (oder Formatter deiner Wahl)

pytest

Pro (wenn Typen wichtig sind):

mypy oder pyright

Copy/Paste‑Block (Quality Gate):

## Quality Gate (immer ausführen)

- Lint:
  - ruff check .
- Format:
  - ruff format --check .
- Tests:
  - python -m pytest

Optional (wenn aktiviert):
- Types:
  - python -m mypy .
  - oder: pyright
Warum python -m pytest: Damit ist klar, dass pytest in der aktiven Python‑Umgebung läuft.

1.3 Sicherheits- und Scope‑Regeln für Cline (was darf Cline, was nicht)
Das ist der Teil, der dir später massiv Ärger spart.

Copy/Paste‑Block (Cline Scope):

## Cline Scope & Safety

- Standard: Plan Mode zuerst. Act Mode erst nach Plan-Freigabe.
- Cline darf nur im Workspace arbeiten (keine Dateien außerhalb).
- Keine neuen Dependencies ohne explizites OK von mir.
- Keine Änderungen an Projekt-/Tooling-Konfig (pyproject.toml, CI, pre-commit, etc.) ohne Nachfrage.
- Keine Neben-Refactors. Nur Änderungen, die zur Aufgabe gehören.
- Terminal: Kommandos nur ausführen, wenn ich sie freigebe.
- Vor jedem Tool-Run: sicherstellen, dass die .venv genutzt wird (sys.executable check, falls unklar).
1.4 Arbeitsweise festnageln: „One‑Step‑Rule“ + Plan/Act‑Ritual
Damit Cline nicht zu viel auf einmal macht.

Copy/Paste‑Block (Session‑Protokoll):

## Arbeitsweise (Plan/Act)

Plan Mode:
- Erstelle einen nummerierten Plan (max 10 Schritte).
- Jeder Schritt nennt: betroffene Dateien + Test/Check danach.

Act Mode:
- Implementiere immer nur 1 Plan-Schritt pro Durchlauf (max 2, wenn ich es ausdrücklich sage).
- Nach jedem Schritt: kurz "Was wurde geändert?" + genau 1 Kommando fürs Quality Gate.
- Wenn Scope wächst: zurück in Plan Mode und Plan aktualisieren.
1.5 „Nicht‑Ziele“ als Standard (damit Cline nicht kreativ wird)
Viele Fehler passieren, weil KI „optimiert“, obwohl du nur einen Fix wolltest.

Copy/Paste‑Block (Nicht‑Ziele):

## Standard Nicht-Ziele (sofern nicht ausdrücklich verlangt)

- Keine Umbenennungen über das Feature hinaus
- Kein Formatieren/Lint-Fixing in unbeteiligten Dateien
- Keine Architektur-Umbauten "nebenbei"
- Keine neuen Libraries
- Keine Änderung von Public APIs ohne Rücksprache
1.6 Prompt‑Templates (damit du jedes Issue gleich startest)
Diese drei reichen für 80 % der Arbeit.

Plan Kickoff (Plan Mode):

Plan Mode.
Ziel: …
Akzeptanzkriterien: …
Nicht-Ziele: …
Bitte lies die relevanten Dateien und erstelle einen nummerierten Plan (max 10 Schritte).
Jeder Schritt: betroffene Dateien + Test/Check danach.

Implementiere Schritt 1 (Act Mode):

Act Mode. Implementiere ausschließlich Schritt 1 aus dem Plan.
Keine Neben-Refactors, keine neuen Dependencies.
Danach: sag kurz, was geändert wurde, und nenne genau 1 Kommando für das Quality Gate.

Debug Minimal (Act Mode):

Act Mode. Analysiere nur den Fehleroutput.
Schlage die kleinste Änderung vor, die den Fehler behebt.
Danach erneut Quality Gate (erst nach meiner Freigabe).

Ergebnis von Punkt 1
Wenn du Punkt 1 umgesetzt hast, hast du:

eine klare DoD

ein festes Quality Gate

klare Sicherheits- und Scope‑Grenzen für Cline

eine Arbeitsweise, die Plan/Act wirklich nutzbar macht

Prompt‑Templates, die du jedes Mal wiederverwenden kannst

Wenn du „Weiter“ schreibst, mache ich mit Punkt 2: Windows‑Basis vorbereiten weiter (Ordnerstruktur, Git‑Konfig, Terminal‑Standard, typische Windows‑Fallstricke).

Du:
Weiter 
ChatGPT:
Reasoned for 4m 27s
Punkt 2: Windows‑Basis für Development vorbereiten
Ziel dieses Punkts: Dein Windows‑Setup ist so „ruhig“ und konsistent, dass VS Code + Git + Terminal später zuverlässig funktionieren (ohne OneDrive‑Ärger, Pfadprobleme, Terminal‑Chaos).

2.1 Saubere Projektpfade anlegen (wichtigster Windows‑Hack)
Lege einen festen Dev‑Root an (kurz, lokal, ohne Sync), z. B.:

C:\dev\projects\

Nutze pro Repo einen Ordner darunter, z. B.:

C:\dev\projects\mein-repo\

Warum:

Kürzere Pfade reduzieren Probleme mit venvs, Tooling, Node‑Dependencies usw.

OneDrive/Dropbox kann File‑Watcher, Locks und Performance stören.

2.2 Terminal-Standard festlegen (damit Commands reproduzierbar sind)
Empfehlung: PowerShell als Standard (für Windows‑Kommandos, Skripte wie check.ps1 usw.).

Optional (sehr sinnvoll): PowerShell 7 installieren

PowerShell 7 (pwsh) ist oft stabiler/moderner als Windows PowerShell 5.1.

Du kannst später in VS Code als Default Profile pwsh wählen.

VS Code Einstellung:

VS Code → Terminal → Select Default Profile

Wähle PowerShell oder PowerShell 7 (pwsh)

Ziel: Du nutzt in allen Anleitungen später dieselbe Shell.

2.3 Git installieren und einmal sauber konfigurieren
Installiere Git for Windows.

Öffne PowerShell und prüfe:

git --version
where git
Setze globale Git‑Basics:

git config --global user.name "Dein Name"
git config --global user.email "du@beispiel.de"
git config --global init.defaultBranch main
Lange Pfade (wichtig bei Windows):

git config --global core.longpaths true
Line Endings (solider Windows‑Default):

git config --global core.autocrlf true
git config --global core.safecrlf warn
Hinweis: In Teams kann das per .gitattributes project‑weit geregelt werden. Wenn ein Projekt das bereits hat, gilt die Repo‑Regel.

2.4 Optional, aber „pro“: Windows Long Paths systemweit aktivieren
Git kann lange Pfade nutzen, aber Windows selbst kann (je nach Konfiguration) trotzdem limitieren.

Option A (Pro/Enterprise, wenn Gruppenrichtlinien verfügbar):

Gruppenrichtlinieneditor →
Computer Configuration → Administrative Templates → System → Filesystem → Enable Win32 long paths → Enabled

Option B (Registry, wenn du weißt was du tust):

Schlüssel:
HKLM\SYSTEM\CurrentControlSet\Control\FileSystem

DWORD: LongPathsEnabled = 1

Wenn du das nicht anfassen willst: Mit kurzen Pfaden (C:\dev\...) kommst du sehr weit.

2.5 Authentifizierung: HTTPS oder SSH (wähle eins)
Variante 1: HTTPS (einfach, gut genug)

Git for Windows bringt üblicherweise den Credential Manager mit.

Beim ersten git pull/push wirst du dich anmelden (Token/Browser‑Flow je nach Plattform).

Variante 2: SSH (pro, weniger Re‑Auth)

Prüfe, ob OpenSSH vorhanden ist:

ssh -V
Key erzeugen (Beispiel):

ssh-keygen -t ed25519 -C "du@beispiel.de"
Public Key anzeigen:

type $env:USERPROFILE\.ssh\id_ed25519.pub
Den Public Key bei GitHub/GitLab/Bitbucket hinterlegen.

2.6 VS Code + Git: einmal „sauber“ verproben
Lege ein Test‑Repo an:

mkdir C:\dev\projects\git-smoke
cd C:\dev\projects\git-smoke
git init
echo "# git-smoke" > README.md
git add README.md
git commit -m "init"
Öffne den Ordner in VS Code und prüfe:

Source Control Panel zeigt den Commit

Terminal läuft im richtigen Profil (PowerShell/pwsh)

2.7 Mini‑Checkliste: Punkt 2 ist „fertig“, wenn …
Du arbeitest in C:\dev\projects\... (nicht OneDrive)

git --version funktioniert

git config --global core.longpaths true ist gesetzt

VS Code nutzt ein bestätigtes Default‑Terminalprofil

Ein Test‑Commit ging durch

Wenn du „Weiter“ schreibst, mache ich mit Punkt 3: Python sauber installieren und Versionen kontrollieren weiter (inkl. typischer Windows‑Aliase/Store‑Fallen, py Launcher, und venv‑Standard).

Du:
Weiter 
ChatGPT:
Reasoned for 4m 53s
Punkt 3: Python sauber installieren und Versionen kontrollieren (Windows)
Ziel dieses Punkts: Du hast eine eindeutige, stabile Python‑Installation auf dem Rechner, du weißt jederzeit „welches Python“ du nutzt, und du vermeidest die typischen Windows‑Fallen (Store‑Aliase, falscher PATH, mehrere Installationen).

3.1 Entscheide dich für eine Python‑Quelle
Für ein normales Python‑Dev‑Setup (Apps, Tools, Skripte) ist am zuverlässigsten:

python.org (Empfehlung)
Gut kompatibel mit VS Code, venv, pip, CI.

Alternative nur bei Bedarf:

Conda/Miniconda: wenn du bewusst ein Data‑Science‑Ökosystem brauchst (NumPy/BLAS, komplexe native Pakete), sonst zusätzlicher Overhead.

Microsoft Store Python: eher vermeiden, weil Windows‑Aliase und Pfadlogik öfter verwirren.

3.2 Installation von python.org richtig machen
Installer starten (64‑bit).

Wichtig im Installer:

“Add Python to PATH” aktivieren

“Install launcher for all users (recommended)” aktivieren (der py‑Launcher ist Gold wert)

Installieren.

Warum der py‑Launcher so wichtig ist:

Er hilft dir, mehrere Python‑Versionen sauber zu verwalten und gezielt zu starten (z. B. py -3.12).

3.3 Windows‑Falle: App Execution Aliases (python öffnet den Store)
Wenn python oder python3 den Microsoft Store öffnet oder „Python wurde nicht gefunden“ kommt:

Windows Einstellungen → Apps → App‑Ausführungsaliase

Deaktiviere:

python.exe

python3.exe

Danach: Terminal schließen und neu öffnen.

3.4 Health Check: Welche Python‑Version(en) sind installiert?
Öffne PowerShell (oder dein Standard‑Terminal) und führe aus:

py --version
py -0p
py -0p listet alle erkannten Python‑Installationen inklusive Pfad.
Das ist dein „Single Source of Truth“.

Zusätzlich:

python --version
where python
where py
Wenn where python mehrere Treffer zeigt, ist das nicht automatisch falsch – aber du solltest wissen, welches du tatsächlich nutzt. Für reproduzierbares Arbeiten empfehle ich, dich in Scripts/Docs primär auf py zu stützen.

3.5 pip „gesund“ machen
py -m pip install --upgrade pip setuptools wheel
Damit vermeidest du viele Installationsprobleme (alte Build‑Tools, alte Wheel‑Logik).

3.6 (Optional, aber sehr hilfreich) Wenn pip native Builds verlangt
Wenn du Pakete installierst und Fehler wie „Microsoft Visual C++ Build Tools required“ bekommst:

Installiere die Microsoft C++ Build Tools (Visual Studio Build Tools) inkl. „Desktop development with C++“.

In vielen Projekten brauchst du das nicht, weil Wheels verfügbar sind, aber wenn es knallt, ist das der typische Fix.

3.7 Standard: pro Projekt eine venv, nicht global installieren
Noch kein .venv anlegen – das kommt als Prozessschritt in Punkt 5 –, aber du solltest dir jetzt schon merken:

Global installierte Pakete sind unter Windows oft eine Fehlerquelle (Versionsmix).

Der Pro‑Standard ist: pro Repo .venv/ und Tools darüber.

3.8 Minimaler Diagnose‑Block (immer nutzen, wenn etwas komisch wirkt)
Diese drei Zeilen klären 90 % der „falsches Python“‑Probleme:

py -0p
python --version
python -c "import sys; print(sys.executable)"
Später, wenn .venv aktiv ist, muss sys.executable auf ...\<repo>\.venv\Scripts\python.exe zeigen.

3.9 Punkt‑3‑Checkliste: fertig, wenn …
py --version funktioniert

py -0p zeigt dir die Installation(en) + Pfade

python öffnet nicht den Store (Aliase sind aus, falls nötig)

pip ist aktualisiert (pip/setuptools/wheel)

du weißt: für Projekte nutzt du später .venv statt global

Wenn du „Weiter“ schreibst, mache ich mit Punkt 4: Projekt‑Grundlage anlegen weiter (Repo‑Layout, .gitignore, minimaler Python‑Projektaufbau, damit VS Code + Cline später ideal arbeiten).

Du:
Weiter 
ChatGPT:
Reasoned for 11m 13s
Punkt 4: Projekt‑Grundlage anlegen (Repo‑Layout, .gitignore, pyproject.toml, Tests)
Ziel dieses Punkts: Du hast ein Repo, das „sofort sinnvoll“ ist: klare Struktur, saubere Ignore‑Regeln, Tool‑Konfiguration an einem Ort (pyproject.toml) und ein Test‑Gerüst. Damit laufen VS Code, spätere Toolchain (Ruff/pytest) und Cline deutlich stabiler.

4.1 Projektordner anlegen und Repo initialisieren
In PowerShell:

cd C:\dev\projects
mkdir <projektname>
cd <projektname>
git init
In VS Code: File → Open Folder… → C:\dev\projects\<projektname>

4.2 Layout wählen: „App/Tool“ oder „Library“ (empfohlene Default‑Struktur)
Ich gebe dir zwei verbreitete Varianten. Wenn du nicht sicher bist: nimm Variante A (einfach, für Apps/Tools optimal). Du kannst später immer noch auf „src layout“ wechseln.

Variante A (empfohlen als Standard für Apps/Tools)
<projektname>/
  <paketname>/
    __init__.py
    main.py
  tests/
    test_smoke.py
  pyproject.toml
  README.md
  .gitignore
Vorteil: schnell, wenig Konfig.

Ideal für CLI‑Tools, Skript‑Sammlungen, Services.

Variante B („src layout“, oft für Libraries)
<projektname>/
  src/
    <paketname>/
      __init__.py
      main.py
  tests/
    test_smoke.py
  pyproject.toml
  README.md
  .gitignore
Vorteil: verhindert viele Import‑Fehler (Tests importieren nicht „aus Versehen“ aus dem Projektroot).

Gut, wenn du das als Paket/Library veröffentlichen willst.

Für den Lern‑ und Cline‑Workflow reicht Variante A völlig.

4.3 Dateien/Ordner erstellen (Variante A)
Passe <paketname> an (z. B. my_app, nur klein + underscore).

mkdir <paketname>
mkdir tests
New-Item -ItemType File -Force README.md, pyproject.toml, .gitignore
New-Item -ItemType File -Force <paketname>\__init__.py, <paketname>\main.py, tests\test_smoke.py
4.4 Minimaler Code‑Stub (damit sofort etwas testbar ist)
<paketname>/main.py

def add(a: int, b: int) -> int:
    return a + b
tests/test_smoke.py

from <paketname>.main import add


def test_add_smoke() -> None:
    assert add(1, 2) == 3
Das ist bewusst simpel: Ziel ist, dass du später mit Ruff/pytest sofort einen grünen Baseline‑Lauf bekommst.

4.5 pyproject.toml als zentrale Tool‑Konfiguration
Du kannst pyproject.toml auch ohne Packaging‑Metadaten nutzen (nur für Tools). Das ist für den Start am unkompliziertesten.

pyproject.toml (Tool‑Config‑Minimum):

[tool.ruff]
line-length = 100

[tool.ruff.lint]
select = ["E", "F", "I", "B", "UP"]

[tool.pytest.ini_options]
testpaths = ["tests"]
addopts = "-q"
Optional (später, wenn du „Pro“ aufdrehen willst):

strictere Regeln (z. B. select erweitern)

mypy/pyright Config ergänzen

Packaging‑Block [project] hinzufügen (wenn du editable installs/Distribution willst)

4.6 .gitignore (solider Start für Python unter Windows)
.gitignore

# Python virtual environments
.venv/

# Python caches
__pycache__/
*.py[cod]
.pytest_cache/
.ruff_cache/
.mypy_cache/

# Build artifacts
build/
dist/
*.egg-info/

# Coverage / reports
.coverage
htmlcov/

# OS / editor noise
Thumbs.db

# Secrets / env (wenn du sie nutzt)
.env
.env.*
Wichtig: .venv/ gehört praktisch immer in .gitignore.

4.7 Baseline‑Commit (sehr empfehlenswert)
Bevor du Tooling installierst/änderst, committe einmal den „Projekt‑Sockel“. Das macht spätere Diffs und Cline‑Änderungen viel übersichtlicher.

git add -A
git commit -m "chore: scaffold project structure"
4.8 Ergebnis von Punkt 4
Du hast jetzt:

ein sauberes Repo‑Layout

pyproject.toml als zentrale Stelle für Ruff/pytest‑Konfiguration

ein minimal testbares Stück Code

.gitignore, sodass venv/caches nicht im Repo landen

einen Baseline‑Commit

Wenn du „Weiter“ schreibst, mache ich mit Punkt 5: Virtuelle Umgebung + Toolchain bootstrappen weiter (.venv, pip, ruff, pytest, optional pre-commit, optional mypy/pyright) – so, dass es auf Windows wirklich stabil läuft.

Du:
Weiter 
ChatGPT:
Reasoned for 5m 38s
Punkt 5: Virtuelle Umgebung und Toolchain bootstrappen
Ziel dieses Punkts: Du hast pro Projekt eine isolierte Python‑Umgebung (.venv) und die wichtigsten Dev‑Tools installiert, sodass du ab jetzt jederzeit reproduzierbar linten und testen kannst.

5.1 .venv erstellen (im Repo‑Root)
Im VS‑Code‑Terminal (PowerShell), im Projektordner:

cd C:\dev\projects\<projektname>
py -m venv .venv
Wenn du mehrere Python‑Versionen installiert hast und eine bestimmte willst:

py -3.12 -m venv .venv
5.2 .venv aktivieren (oder bewusst ohne Aktivierung arbeiten)
Normalfall (mit Aktivierung):

.\.venv\Scripts\Activate.ps1
Wenn PowerShell blockiert (Execution Policy), dann einmalig für deinen User:

Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
Pro‑Alternative (ohne Aktivierung, extrem robust):
Wenn du Aktivierung vermeiden willst (oder Cline später mal in Terminal‑Modi zickt), nutze immer den venv‑Python direkt:

.\.venv\Scripts\python.exe -m pip --version
Das ist auf Windows oft die stabilste Variante, weil du nie „aus Versehen“ im globalen Python landest.

5.3 Baseline‑Checks: Bin ich wirklich in der .venv?
Wenn aktiviert, prüfe:

python -c "import sys; print(sys.executable)"
python -m pip --version
Erwartung: sys.executable zeigt auf ...\<repo>\.venv\Scripts\python.exe.

Wenn du nicht aktiviert hast, dann entsprechend:

.\.venv\Scripts\python.exe -c "import sys; print(sys.executable)"
.\.venv\Scripts\python.exe -m pip --version
5.4 pip (und Build‑Tools) aktualisieren
In der .venv:

python -m pip install -U pip setuptools wheel
(oder ohne Aktivierung)

.\.venv\Scripts\python.exe -m pip install -U pip setuptools wheel
5.5 Dev‑Tools installieren: Ruff + pytest (Minimum)
python -m pip install -U ruff pytest
Kurz prüfen:

python -m ruff --version
python -m pytest --version
5.6 Baseline‑Lauf: Lint + Tests müssen grün sein
Mit dem Mini‑Test aus Punkt 4:

python -m ruff check .
python -m pytest
Wenn das grün ist, weißt du: Python‑Pfad, Imports, Test‑Discovery und Basis‑Tooling stimmen.

5.7 Optional: Dev‑Dependencies dokumentieren (sehr empfehlenswert)
Wenn du pip nutzt und es simpel halten willst, lege eine requirements-dev.txt an:

requirements-dev.txt

ruff
pytest
Dann können andere (oder du später) mit einem Befehl bootstrappen:

python -m pip install -r requirements-dev.txt
Pro‑Hinweis: Versions‑Pinning (genau definierte Versionen) ist ein eigener Schritt. Für den Anfang reicht „unpinned“, solange du ein Quality Gate hast. Wenn du später absolute Reproduzierbarkeit willst, machen wir das mit pip-tools oder uv (kann man sauber in den Prozess einbauen).

5.8 Ergebnis von Punkt 5
Du hast jetzt:

eine funktionierende .venv im Repo

aktuelles pip/setuptools/wheel

ruff + pytest installiert

Baseline‑Lint und Baseline‑Tests laufen grün

Wenn du „Weiter“ schreibst, mache ich mit Punkt 6: VS Code für Python stabil konfigurieren weiter (Interpreter fest auf .venv, Ruff/Format‑Konflikte vermeiden, pytest sauber im Test Explorer).

Du:
Weiter 
ChatGPT:
Reasoned for 5m 33s
Punkt 6: VS Code für Python stabil konfigurieren
Ziel dieses Punkts: VS Code nutzt zuverlässig deine .venv, führt pytest sauber aus und hat ein klares Lint/Format‑Setup (ohne Tool‑Konflikte). Danach kannst du Cline später sicher einsetzen, weil Terminal‑Runs und Tests reproduzierbar sind.

6.1 Pflicht-Extensions installieren
In VS Code: Extensions (Strg + Shift + X)

Installiere mindestens:

Python (Microsoft)

Ruff (Ruff Linter/Formatter)

Optional (nur wenn du es brauchst):

Jupyter (wenn Notebook‑Workflow)

GitLens (wenn du viel Git im Editor machst)

Wichtig: Entscheide dich für Ruff als Formatter oder Black als Formatter. Nicht beides parallel aktiv als Default‑Formatter.

6.2 Workspace-Settings anlegen (Repo‑lokal, reproduzierbar)
Lege im Repo diese Datei an:

<repo>/.vscode/settings.json

Wenn .vscode/ noch nicht existiert, erstelle den Ordner.

Empfohlener Start‑Inhalt:

{
  // Terminal: venv automatisch aktivieren (wenn VS Code es kann)
  "python.terminal.activateEnvironment": true,

  // Python: Tests
  "python.testing.pytestEnabled": true,
  "python.testing.unittestEnabled": false,
  "python.testing.pytestArgs": ["tests"],

  // Editor: Python-Dateien beim Speichern formatieren + Ruff-Fixes
  "[python]": {
    "editor.formatOnSave": true,
    "editor.codeActionsOnSave": {
      "source.fixAll.ruff": "explicit",
      "source.organizeImports.ruff": "explicit"
    }
  }
}
Wenn VS Code/Extensions bei dir source.fixAll.ruff nicht kennen (selten, aber möglich), nimm als Fallback:

"editor.codeActionsOnSave": {
  "source.fixAll": "explicit",
  "source.organizeImports": "explicit"
}
(und stelle sicher, dass Ruff der aktive Linter/Import‑Organizer ist).

6.3 Interpreter fest auf .venv setzen
Öffne das Repo in VS Code (Ordner‑Workspace).

Strg + Shift + P → Python: Select Interpreter

Wähle den Interpreter in deinem Projekt:

...\<repo>\.venv\Scripts\python.exe

Wenn .venv nicht angezeigt wird:

Wähle „Enter interpreter path…“ und navigiere manuell zu .venv\Scripts\python.exe.

Sofort-Check im VS Code Terminal:

python -c "import sys; print(sys.executable)"
Erwartung: Pfad zeigt auf ...\<repo>\.venv\Scripts\python.exe.

6.4 Terminal-Profil vereinheitlichen (damit Commands immer gleich laufen)
In VS Code:

Terminal → Select Default Profile

Empfehlung: PowerShell oder PowerShell 7 (pwsh)

Danach:

Terminal schließen

Neues Terminal öffnen (damit Aktivierung der venv sauber greift)

6.5 Ruff sauber als Lint + Format nutzen (Konflikte vermeiden)
A) Ruff als Default-Formatter setzen
Damit „Format Document“ und „Format on Save“ wirklich Ruff nutzen:

Öffne eine .py Datei

Rechtsklick → Format Document With… → Configure Default Formatter…

Wähle Ruff

Wenn du stattdessen Black nutzen willst:

Dann setze Black als Default Formatter und nutze Ruff nur fürs Linting/Fixes.

Entscheidend ist: nur ein Default Formatter.

B) Sicherstellen, dass Ruff im Projekt installiert ist
In deiner .venv:

python -m pip install -U ruff
C) Basis-Config in pyproject.toml (falls noch nicht vorhanden)
[tool.ruff]
line-length = 100

[tool.ruff.lint]
select = ["E", "F", "I", "B", "UP"]
6.6 pytest in VS Code aktivieren (Test Explorer)
Voraussetzung: pytest ist in .venv installiert:

python -m pip install -U pytest
Dann in VS Code:

Links das Testing Icon öffnen

„Configure Tests“ auswählen

pytest wählen

Test‑Ordner bestätigen (typisch: tests/)

Wenn Tests nicht auftauchen:

Prüfe, ob du wirklich den .venv Interpreter nutzt (siehe 6.3)

Prüfe, ob es überhaupt tests/test_*.py gibt

Einmal VS Code neu starten

6.7 Smoke Test (2 Minuten) – danach ist Punkt 6 erledigt
Im VS Code Terminal:

Interpreter check:

python -c "import sys; print(sys.executable)"
Ruff:

python -m ruff check .
pytest:

python -m pytest
Wenn das alles sauber läuft, ist VS Code „Python‑ready“ und du hast eine stabile Basis für Cline.

Wenn du „Weiter“ schreibst, mache ich mit Punkt 7: Quality‑Gate automatisieren (scripts/check.ps1 + scripts/fix.ps1) weiter, sodass du für „grün/rot“ nur noch einen einzigen Befehl brauchst.

Du:
Weiter 
ChatGPT:
Reasoned for 3m 59s
Punkt 7: Quality‑Gate automatisieren (ein Befehl für „grün/rot“)
Ziel dieses Punkts: Du hast in jedem Repo genau einen Standardbefehl, der zuverlässig unter Windows läuft – auch wenn die venv im Terminal gerade nicht aktiviert ist. Das macht VS Code, Cline und deinen gesamten Workflow stabiler.

Wir erstellen dafür zwei PowerShell‑Skripte:

.\scripts\check.ps1 → Lint + Format‑Check + Tests (scheitert mit Exit‑Code, wenn etwas rot ist)

.\scripts\fix.ps1 → Ruff‑Fixes + Format + danach optional Tests

7.1 scripts/ Ordner anlegen
Im Repo‑Root:

mkdir scripts
7.2 scripts/check.ps1 erstellen
Lege scripts/check.ps1 an und füge diesen Inhalt ein:

# scripts/check.ps1
# Quality Gate: Ruff lint + Ruff format check + pytest
# Läuft robust, auch wenn keine venv aktiviert ist.

$ErrorActionPreference = "Stop"

$RepoRoot = Split-Path -Parent $PSScriptRoot
$VenvPython = Join-Path $RepoRoot ".venv\Scripts\python.exe"
$VenvRuff   = Join-Path $RepoRoot ".venv\Scripts\ruff.exe"

function Assert-FileExists([string]$Path, [string]$Hint) {
    if (-not (Test-Path $Path)) {
        Write-Host "Fehlt: $Path"
        Write-Host $Hint
        exit 1
    }
}

function Run-Step([string]$Title, [string]$Exe, [string[]]$Args) {
    Write-Host ""
    Write-Host "== $Title =="
    & $Exe @Args
    $code = $LASTEXITCODE
    if ($code -ne 0) {
        Write-Host ""
        Write-Host "FEHLER in Schritt: $Title (Exit Code $code)"
        exit $code
    }
}

Assert-FileExists $VenvPython "Erstelle die venv im Repo-Root:  py -m venv .venv"
Assert-FileExists $VenvRuff   "Installiere ruff in der venv:      .\.venv\Scripts\python.exe -m pip install -U ruff"
# pytest wird über python -m pytest gestartet, daher kein eigener exe-check nötig.

# 0) Interpreter-Check (hilft enorm bei Debugging)
Run-Step "Python Interpreter" $VenvPython @("-c", "import sys; print(sys.executable)")

# 1) Lint
Run-Step "Ruff (lint)" $VenvRuff @("check", ".")

# 2) Format-Check (bricht ab, wenn Formatierung nicht passt)
Run-Step "Ruff (format check)" $VenvRuff @("format", "--check", ".")

# 3) Tests
Run-Step "Pytest" $VenvPython @("-m", "pytest")
Was dieses Skript „pro“ macht:

Es nutzt explizit .venv\Scripts\python.exe und .venv\Scripts\ruff.exe → kein PATH‑Chaos, keine „falsche Python“-Fälle.

Es beendet sich bei Fehlern mit einem Exit‑Code → ideal für CI, VS Code Tasks und Cline.

7.3 scripts/fix.ps1 erstellen (Ruff Fixes + Format)
Lege scripts/fix.ps1 an:

# scripts/fix.ps1
# Wendet Ruff-Fixes an und formatiert den Code.
# Empfehlung: vorher git status clean oder einen Commit/Checkpoint haben.

$ErrorActionPreference = "Stop"

$RepoRoot = Split-Path -Parent $PSScriptRoot
$VenvPython = Join-Path $RepoRoot ".venv\Scripts\python.exe"
$VenvRuff   = Join-Path $RepoRoot ".venv\Scripts\ruff.exe"

function Assert-FileExists([string]$Path, [string]$Hint) {
    if (-not (Test-Path $Path)) {
        Write-Host "Fehlt: $Path"
        Write-Host $Hint
        exit 1
    }
}

function Run-Step([string]$Title, [string]$Exe, [string[]]$Args) {
    Write-Host ""
    Write-Host "== $Title =="
    & $Exe @Args
    $code = $LASTEXITCODE
    if ($code -ne 0) {
        Write-Host ""
        Write-Host "FEHLER in Schritt: $Title (Exit Code $code)"
        exit $code
    }
}

Assert-FileExists $VenvPython "Erstelle die venv im Repo-Root:  py -m venv .venv"
Assert-FileExists $VenvRuff   "Installiere ruff in der venv:      .\.venv\Scripts\python.exe -m pip install -U ruff"

Run-Step "Ruff (lint + fix)" $VenvRuff @("check", ".", "--fix")
Run-Step "Ruff (format)"     $VenvRuff @("format", ".")

# Optional: danach direkt testen (empfohlen)
Run-Step "Pytest" $VenvPython @("-m", "pytest")
Empfehlung für den Alltag:

fix.ps1 nur dann nutzen, wenn du auch wirklich bereit bist, Code zu verändern (und du danach reviewst).

7.4 Kurztest: Skripte laufen lassen
Im Repo‑Root:

.\scripts\check.ps1
Wenn du absichtlich einen Formatfehler provozierst (z. B. Leerzeilen), sollte check.ps1 sauber rot werden.

Dann:

.\scripts\fix.ps1
.\scripts\check.ps1
7.5 Ein Satz, der dir später mit Cline extrem hilft
Ab jetzt ist dein Standard nach jedem Cline‑Schritt:

„Führe .\scripts\check.ps1 aus und behebe nur das, was rot ist.“

Damit muss Cline nicht mehr raten, welche Kommandos es laufen lassen soll, und du bekommst reproduzierbares Verhalten.

Wenn du „Weiter“ schreibst, mache ich mit Punkt 8: Cline installieren und mit sicherem Startprofil betreiben weiter (Approvals, Terminal‑Modus, erstes „Plan‑only“ Onboarding im Repo).

Du:
Weiter 
ChatGPT:
Reasoned for 7m 29s
Punkt 8: Cline installieren und mit sicherem Startprofil betreiben
Ziel dieses Punkts: Cline ist in VS Code installiert, du findest die wichtigen Menüs (Plan/Act, Settings), und du startest mit einem Sicherheitsprofil, das produktiv ist, aber Risiken minimiert (keine ungewollten Edits/Commands).

8.1 Installation in VS Code und Öffnen
Extensions öffnen

Strg + Shift + X → im Marketplace nach “Cline” suchen → Install. 
Cline
+1

Cline öffnen

Cline‑Icon in der Activity Bar anklicken, oder

Strg + Shift + P → “Cline: Open In New Tab”. 
Cline

Wenn VS Code nach einer Berechtigung fragt („Running extensions might…“), Allow klicken; falls das Icon nicht erscheint: VS Code komplett neu starten. 
Cline

8.2 Sign‑in (falls du den Cline‑Provider nutzt)
Wenn du den Cline‑Provider (Account‑Login) nutzen willst:

Im Cline‑Panel auf Sign Up / Sign In klicken → du wirst zu app.cline.bot weitergeleitet und danach zurück in den Editor. 
Cline

(Provider/Model‑Feintuning machen wir in Punkt 9; hier geht’s erstmal um „läuft sicher“.)

8.3 Auto Approve: sichere Standard‑Konfiguration (empfohlen)
Cline hat Auto Approve, damit du nicht ständig dieselben harmlosen Bestätigungen klicken musst. Gleichzeitig kannst du riskante Dinge weiterhin manuell freigeben. 
Cline

Empfohlenes Start‑Profil (genau so, wie Cline es selbst empfiehlt):

An: Read project files

Aus: Edit project files, Execute safe commands, Use the browser, Use MCP servers

Aus: Read all files (außerhalb Workspace)

Aus: Edit all files (außerhalb Workspace) 
Cline

Wichtiges Detail: Read all files und Edit all files erweitern nur die Basis‑Option (wenn Basis aus ist, tun sie nichts). Und bei Commands ist „safe vs approval required“ nicht starr, sondern wird pro Kommando bewertet – deshalb ist „Command Auto‑Approve“ am Anfang meistens besser aus. 
Cline

8.4 YOLO Mode: aus lassen (und warum)
YOLO Mode umgeht die granularen Freigaben und auto‑approved sehr weitreichend (Dateien überall am System, Terminal‑Commands inkl. potenziell destruktiver Aktionen, Browser‑Aktionen, MCP‑Tools, sogar Mode‑Transitions Plan→Act). Für Lernen und produktive Repos: normalerweise nein. 
Cline
+1

8.5 Checkpoints: aktiv lassen (Sicherheitsnetz für KI‑Änderungen)
Checkpoints sind standardmäßig aktiv und speichern nach jedem Tool‑Schritt einen Snapshot deines Workspace (Edits, Commands etc.). Du kannst dadurch Änderungen schrittweise prüfen und bei Bedarf zurückrollen, ohne deinen normalen Git‑Workflow zu zerstören. 
Cline

Wo du es findest: Cline Settings → Feature Settings → Enable Checkpoints (an/aus). 
Cline

8.6 Explain Changes für Review nutzen (sehr hilfreich)
Wenn Cline Code geändert hat, kannst du im Abschluss‑Bereich neben „View Changes“ eine Funktion Explain Changes nutzen, die dir inline im Diff erklärt, was warum geändert wurde. Das ist ideal für Review und Knowledge Transfer. Diese Funktion braucht aktivierte Checkpoints. 
Cline
+1

8.7 Terminal‑Modus: erst normal, bei Problemen „Background Exec“
Wenn Cline bei Terminal‑Ausführung hängt, keinen Output sieht oder „komisch“ reagiert:

Cline Settings → Terminal Settings → Terminal Execution Mode → Background Exec. 
Cline
+1

Das ist laut Cline‑Troubleshooting der schnellste Fix, weil Commands dann in einem Hintergrundprozess laufen statt im VS‑Code‑Terminal und damit viele Integrationsprobleme umgangen werden. 
Cline
+1

Pro‑Tipp: Weil wir ab Punkt 7 ein .\scripts\check.ps1 haben, kannst du Cline fast immer nur dieses Script ausführen lassen – das vermeidet Windows‑Quoting‑Edgecases und macht Runs reproduzierbar.

8.8 Erstes „Onboarding“ im Repo: Plan‑only, dann ein kontrollierter Act‑Step
Cline’s eigener Workflow empfiehlt: signifikante Tasks immer in Plan Mode starten, dann erst in Act Mode umsetzen. 
Cline

A) Plan Mode – nur Orientierung, keine Änderungen
Prompt (Copy/Paste):

Plan Mode.
Lies bitte README.md, pyproject.toml und scripts/check.ps1.
Erkläre mir in 6–10 Zeilen:

wie ich das Quality Gate ausführe,

welche Dateien du für typische Änderungen anfassen würdest,

welche Risiken du siehst (z. B. venv/Imports).
Keine Codeänderungen, keine Commands ausführen.

B) Act Mode – nur ein harmloser Kommando‑Check
Prompt (Copy/Paste):

Act Mode. Führe ausschließlich .\scripts\check.ps1 aus.
Wenn es fehlschlägt: erkläre nur den Fehler und schlage die kleinste Änderung vor. Keine weiteren Verbesserungen.

Ergebnis von Punkt 8
Wenn Punkt 8 erledigt ist, gilt:

Cline ist installiert und öffnet sauber in VS Code. 
Cline

Du startest sicher: Auto Approve nur „Read project files“, alles andere manuell. 
Cline

YOLO ist aus. 
Cline
+1

Checkpoints sind an (Rollback‑Sicherheit). 
Cline

Terminal kann bei Bedarf auf Background Exec umgestellt werden. 
Cline
+1

Du hast den Plan→Act‑Rhythmus praktisch getestet. 
Cline

Wenn du „Weiter“ schreibst, machen wir mit Punkt 9: Provider/Modelle wie ein Pro nutzen weiter (Plan/Act getrennte Modelle, Kosten-/Kontextdisziplin, sinnvolle Defaults für Python‑Workflows).

Du:
Weiter 
ChatGPT:
Reasoned for 8m 40s
Punkt 9: Provider und Modelle wie ein Pro nutzen (Plan/Act getrennt, Kosten und Zuverlässigkeit im Griff)
Ziel dieses Punkts: Du stellst Cline so ein, dass du schnell, günstig und trotzdem zuverlässig arbeitest – vor allem bei Python‑Workflows mit Tests/Linting. Der Kern ist: Plan Mode = denken, Act Mode = umsetzen + Tools laufen lassen.

9.1 Leitprinzip: Plan und Act bewusst unterschiedlich behandeln
Cline empfiehlt explizit, separate Modelle für Plan Mode und Act Mode zu konfigurieren: z. B. ein günstigeres Modell fürs Planen und ein stärkeres Modell für die Umsetzung. 
Cline

Warum das in der Praxis funktioniert:

Plan Mode braucht: gutes Denken, Struktur, Architektur‑Entscheidungen, große Kontextfenster (damit es Code/Struktur versteht).

Act Mode braucht: gute Code‑Qualität, Zuverlässigkeit bei Tool‑Ausgaben (Fehlerlogs richtig interpretieren), saubere minimal‑Fixes.

9.2 Provider‑Wahl: einfache Faustregeln
Cline selbst beschreibt typische Provider‑Stärken (vereinfacht):

Cline (Account‑Login): am schnellsten startklar, keine eigenen API‑Keys nötig. 
Cline

OpenRouter: viele Modelle über einen Provider, oft gut fürs Experimentieren/Preis‑Leistung; Cline kann die Modellliste automatisch abrufen. 
Cline
+1

Direkte Provider (z. B. Anthropic/OpenAI/Gemini): oft stabil und klar, wenn du dich auf eine Modellfamilie festlegen willst. 
Cline

Lokal (Ollama): Privacy/Offline. 
Cline

Pro‑Entscheidungshilfe:

Willst du schnell starten und wenig Admin? → Cline Provider

Willst du flexibel Modelle wechseln? → OpenRouter

Willst du maximale “Tool‑Reliability”/Stabilität bei einem Anbieter? → direkter Provider

Willst du offline/privat? → lokal

9.3 So stellst du Provider und Modelle ein (Cline Settings)
Cline beschreibt dafür einen klaren Ablauf: Settings öffnen → Provider wählen → Key/Sign‑In → Modell wählen. 
Cline
+1

Settings öffnen

In Cline oben rechts auf das Settings‑Symbol klicken (Zahnrad), oder

Ctrl + Shift + P → „Cline: Open Settings“ 
Cline

API Provider auswählen

Dropdown „API Provider“ → Provider wählen 
Cline
+1

Auth

Wenn Provider = Cline: einloggen (kein API‑Key) 
Cline

Sonst: API‑Key vom Provider holen und in Cline eintragen
Cline sagt auch: der Key wird im Secrets Storage des Editors gespeichert (nicht im Repo). 
Cline

Model auswählen

Danach wird das Model‑Dropdown aktiv. 
Cline
+1

9.4 Plan/Act getrennte Modelle aktivieren (und richtig prüfen)
In Cline gibt es eine Option, getrennte Modelle für Plan und Act zu nutzen; das wird in der Model‑Selection‑Doku explizit empfohlen. 
Cline

Pro‑Vorgehen:

Aktiviere „separate models for Plan and Act“ (sinngemäß: „Use different models…“).

Setze Plan‑Modell.

Setze Act‑Modell.

Danach: noch einmal kontrollieren, ob beide Werte wirklich gespeichert sind.

Warum der Kontrollschritt wichtig ist:
Es gibt bekannte Fälle, in denen beim Wechsel zwischen Plan/Act in bestimmten Konstellationen (z. B. „OpenAI‑compatible provider“) die Konfiguration überschrieben wird. 
GitHub

Wenn du das Problem bei dir siehst:

Als Workaround (bis es in deiner Version gefixt ist):

entweder vorübergehend dasselbe Modell für Plan und Act nutzen

oder auf einen Provider wechseln, bei dem die getrennte Konfiguration stabil funktioniert

und grundsätzlich nach jeder Änderung kurz gegenprüfen

9.5 Konkrete Modell‑Strategien (für Python‑Workflows)
Cline gibt selbst eine „Quick Selection“‑Orientierung und empfiehlt je nach Priorität bestimmte Modelle. 
Cline

Du musst das nicht 1:1 übernehmen, aber es ist ein guter Startpunkt.

Profil 1: „Einfach, stabil“

Plan = Act = ein zuverlässiges Modell
Vorteil: wenig Konfig‑Reibung, gut fürs Lernen.

Profil 2: „Pro‑Standard: günstig planen, stark umsetzen“ (meine Empfehlung)

Plan: Budget/Value‑Modell

Act: Premium‑Modell für Umsetzung + Fehleranalyse
Genau dieses Muster empfiehlt Cline als Pro‑Tipp. 
Cline

Profil 3: „Große Codebase / viel Kontext“

Plan: Modell mit großem Kontextfenster

Act: Modell mit guter Tool‑Zuverlässigkeit (weil Tests/Logs sauber interpretiert werden müssen)

9.6 OpenRouter‑Pro‑Einstellungen (wenn du OpenRouter nutzt)
In der OpenRouter‑Provider‑Doku stehen drei Dinge, die in der Praxis wirklich wichtig sind: 
Cline

Model‑Liste

Cline holt die verfügbaren Modelle automatisch von OpenRouter. 
Cline

Transforms / Prompt‑Kompression („middle‑out“)

OpenRouter bietet eine optionale „middle‑out“ Transform; in Cline aktivierst du sie über „Compress prompts and message chains to the context size“. 
Cline
+1

Pro‑Einsatz: nur dann aktivieren, wenn du wirklich oft am Kontextlimit bist. Besser ist meistens: Kontext sauber halten (nur relevante Dateien, .clineignore nutzen).

Prompt Caching

Für viele Modelle läuft Caching automatisch, aber: bei Gemini‑Modellen via OpenRouter verlangt Cline aktuell eine manuelle Aktivierung („Enable Prompt Caching“ Checkbox). 
Cline

9.7 Zuverlässigkeit: Terminal‑Runs und Tests als „Wahrheit“
Für Pro‑Arbeit gilt: Das Modell darf noch so gut sein – „fertig“ ist es erst, wenn .\scripts\check.ps1 grün ist.

Damit Cline zuverlässig Commands ausführen und Output lesen kann, empfiehlt die offizielle Troubleshooting‑Doku als ersten Fix bei Problemen:

Terminal Execution Mode → Background Exec 
Cline

Zusatz‑Pro‑Hinweis: Wenn du Background Exec nutzt, halte Terminal‑Commands möglichst „quote‑arm“. Genau dafür haben wir in Punkt 7 check.ps1.

9.8 Mini‑Smoke‑Test nach der Konfiguration (2 Minuten)
Plan Mode Prompt:

Plan Mode. Lies pyproject.toml und scripts/check.ps1 und erkläre kurz, wie du in diesem Repo Qualität prüfst. Keine Änderungen, keine Commands.

Act Mode Prompt:

Act Mode. Führe ausschließlich .\scripts\check.ps1 aus.

Wenn das klappt, ist Provider/Model/Terminal‑Loop sauber.

Ergebnis von Punkt 9
Du hast jetzt:

eine klare Provider‑Entscheidung

eine Plan/Act‑Strategie (optimal: getrennte Modelle)

Settings so gesetzt, dass Keys sicher gespeichert werden 
Cline

OpenRouter‑Optionen verstanden (Transforms/Caching) 
Cline
+1

einen Test‑Loop, der „Pro‑Qualität“ erzwingt (check.ps1)

Wenn du „Weiter“ schreibst, kommt Punkt 10: Lernen über ein kleines Python‑Übungsprojekt – mit einem sehr konkreten Ablauf (Plan → Act in Mini‑Schritten → check.ps1 → Commit) und Prompt‑Vorlagen, die du danach in echte Repos übernimmst.

Du:
Weiter 
ChatGPT:
Reasoned for 5m 59s
Punkt 10: Lernen über ein kleines Python‑Übungsprojekt (Plan → Act → Quality Gate → Commit)
Ziel dieses Punkts: Du trainierst den „Pro‑Loop“ mit Cline an einem kleinen Projekt, das trotzdem realistisch ist (mehrere Dateien, Tests, CLI, kleine Refactors). Du lernst dabei nicht nur „Cline bedienen“, sondern vor allem: wie du Cline führst, damit Ergebnisse stabil sind.

Wir bauen als Übungsprojekt ein kleines CLI‑Tool textstats:

Input: Datei oder STDIN

Output: Zeilen, Wörter, Zeichen

Optional: Top‑N Wörter

Tests + Ruff + scripts/check.ps1 als Quality Gate

Alles in kleinen Schritten

10.1 Übungsrepo anlegen (Quickstart)
Wenn du üben willst, ohne dein echtes Repo zu riskieren:

cd C:\dev\projects
mkdir cline-textstats-lab
cd cline-textstats-lab
git init
Empfohlenes Layout (Variante A):

cline-textstats-lab/
  textstats/
    __init__.py
    core.py
    cli.py
  tests/
    test_core.py
  pyproject.toml
  .gitignore
  scripts/
    check.ps1
    fix.ps1
  README.md
Du kannst das Layout und die Skripte aus den vorherigen Punkten wiederverwenden (Punkt 4–7).

10.2 Lernregel: Jede Übung besteht aus 5 Schritten
Spec in 5 Zeilen (Ziel, Akzeptanzkriterien, Nicht‑Ziele)

Plan Mode: Cline erstellt Plan (max 10 Schritte)

Act Mode: Cline implementiert genau 1 Schritt

Quality Gate: .\scripts\check.ps1

Commit

Wenn irgendwo etwas rot ist: erst minimal fixen, dann weiter.

Übung 1: Core‑Logik + Tests (ohne CLI)
Spec (du gibst Cline das als Input)
Ziel: analyze_text(text) liefert {lines, words, chars}

Akzeptanz:

lines: Anzahl \n‑getrennter Zeilen (leerer Text = 0 oder 1? du entscheidest)

words: einfache Tokenisierung (z. B. split auf whitespace)

chars: len(text)

Nicht‑Ziele: keine CLI, kein Dateizugriff

Plan Mode Prompt (Copy/Paste)
Plan Mode.
Wir implementieren nur Core‑Logik in textstats/core.py und Tests in tests/test_core.py.
Bitte erstelle einen Plan (max 8 Schritte).
Jeder Schritt: betroffene Dateien + welcher Test/Check danach (immer .\scripts\check.ps1).
Keine Codeänderungen.

Was du im Plan prüfst:

Sind Edge Cases drin (leer, nur whitespace, mehrere Zeilen)?

Ist die Definition „lines bei leerem Text“ klar? (einmal festlegen, dann testen)

Act Mode Prompt (Copy/Paste)
Act Mode. Implementiere ausschließlich Schritt 1 aus dem Plan.
Keine Neben-Refactors, keine neuen Dependencies.
Danach: führe nur .\scripts\check.ps1 aus (erst nach meiner Freigabe).

Wenn check.ps1 rot ist:

Analysiere nur den Fehleroutput. Schlage die kleinste Änderung vor, die es grün macht. Keine weiteren Verbesserungen.

Dann committen:

git add -A
git commit -m "feat(core): add basic text stats with tests"
Übung 2: Tokenisierung verbessern + Top‑N Wörter (kleiner Refactor)
Spec
Ziel: analyze_text(text, top_n=10) liefert zusätzlich top_words (Liste von (word, count) oder dict)

Tokenisierung: lowercase, nur alphanumerisch (du kannst regex nutzen, aber ohne neue deps)

Akzeptanz: stabile Sortierung (count absteigend, dann alphabetisch)

Nicht‑Ziele: keine CLI, kein IO

Plan Mode Prompt
Plan Mode.
Erweitere Core um top_words.
Constraints: keine neuen Dependencies, Tests müssen die Sortierung absichern.
Erstelle einen Plan (max 10 Schritte) und nenne pro Schritt den Check (.\scripts\check.ps1).
Keine Codeänderungen.

Act Mode Prompt
Act Mode. Implementiere nur den nächsten Schritt aus dem Plan.
Danach: .\scripts\check.ps1.
Wenn rot: minimal fixen, keine Extras.

Commit‑Vorschlag:

git commit -am "feat(core): add top word frequencies"
(Lieber git add -A statt -am, wenn neue Dateien dabei sind.)

Übung 3: CLI (argparse) + Input Datei oder STDIN
Spec
Ziel: python -m textstats.cli --path file.txt funktioniert

Wenn --path fehlt: liest STDIN

Output: klarer Text (oder JSON, nur wenn du willst)

Akzeptanz: Exit Code ≠ 0 bei fehlender Datei, klare Fehlermeldung

Nicht‑Ziele: kein Packaging/Publish

Plan Mode Prompt
Plan Mode.
Wir bauen eine CLI in textstats/cli.py.
Anforderungen: Datei oder STDIN, saubere Fehlermeldungen, Exit Codes.
Core bleibt getrennt von IO.
Erstelle Plan (max 10 Schritte) inkl. Tests (wo sinnvoll) und Quality Gate.
Keine Codeänderungen.

Pro‑Hinweis: CLI‑Tests sind möglich (z. B. über subprocess oder direkte main(argv)), aber du kannst auch minimal starten:

Core bleibt gut getestet

CLI hat wenige, klare Pfade

ggf. 1–2 Tests für parse_args/main(argv) wenn du main(argv) so designst, dass es testbar ist

Act Mode Prompt
Act Mode. Implementiere nur Schritt 1 aus dem Plan.
Keine Neben-Refactors.
Danach: .\scripts\check.ps1.

Commit‑Vorschlag:

git add -A
git commit -m "feat(cli): add argparse entry for file or stdin"
Übung 4: Debug‑Drill (bewusst rot machen, dann minimal fixen)
Ziel: Du trainierst „Cline als Debugger“, ohne dass es dir das Projekt „optimiert“.

Ablauf
Baue absichtlich einen Fehler ein (z. B. ändere in core.py words falsch)

Lass .\scripts\check.ps1 laufen → rot

Nutze diesen Prompt:

Act Mode. Tests sind rot.
Analysiere nur den Fehleroutput.
Schlage die kleinste Änderung vor, die genau diesen Fehler behebt.
Danach erneut .\scripts\check.ps1 (erst nach meiner Freigabe).
Keine Refactors, keine Verbesserungen.

Commit‑Vorschlag:

git add -A
git commit -m "fix(core): correct word counting regression"
10.3 Wie du dich selbst „bewertest“ (Pro‑Kriterien)
Du hast Punkt 10 wirklich gelernt, wenn:

du konsequent Plan→Act nutzt (nicht „einfach loscoden“)

du Cline auf 1 Schritt pro Durchlauf begrenzt

du nach jedem Schritt check.ps1 laufen lässt

du Commits klein hältst

du Cline daran hinderst, Neben‑Refactors zu machen

du Fehler nur minimal fixen lässt (nicht „alles neu“)

10.4 Häufige Lernfallen (und Gegenmittel)
Cline will „gleich alles“ implementieren
→ Prompt: „nur Schritt 1“, „keine Neben‑Refactors“, „max 1 Schritt“

Cline sagt „sollte funktionieren“, ohne Tests laufen zu lassen
→ Regel: „check.ps1 ist die Wahrheit“

CLI wird untestbar
→ main(argv: list[str]) -> int designen, damit Tests möglich sind

Tokenisierung/Edge Cases schwammig
→ Du definierst exakt die Regeln und schreibst Tests, die die Regeln erzwingen

Wenn du „Weiter“ schreibst, kommt Punkt 11: .clinerules, .clineignore und Memory Bank – also wie du aus dem gelernten Workflow ein dauerhaftes, projektweites System machst (damit Cline in echten Repos konsistent bleibt).

Du:
Weiter 
ChatGPT:
Reasoned for 5m 9s
Punkt 11: .clinerules, .clineignore und Memory Bank dauerhaft einsetzen
Ziel dieses Punkts: Aus „Cline kann helfen“ wird ein stabiler, wiederholbarer System‑Workflow. Du sorgst dafür, dass Cline

nicht im falschen Kontext arbeitet (Noise, .venv, Caches),

nicht gegen deine Standards „driftet“,

sich Projektentscheidungen über Sessions hinweg merkt.

Das sind die drei Bausteine:

.clineignore = Was Cline möglichst nie anschauen soll

.clinerules = Wie Cline sich im Projekt verhalten soll

memory-bank/ = Was Cline über das Projekt dauerhaft wissen muss

11.1 .clineignore anlegen (Kontext sauber halten)
Lege im Repo‑Root eine Datei .clineignore an.

Empfohlener Startinhalt für Python‑Repos:

# Virtual env + caches
.venv/
__pycache__/
.pytest_cache/
.ruff_cache/
.mypy_cache/
.pyright/

# Build artifacts
build/
dist/
*.egg-info/

# Coverage / reports
.coverage
htmlcov/
*.log

# Secrets / env
.env
.env.*
Wichtige Hinweise:

.venv/ gehört hier unbedingt rein, sonst “ersäuft” Cline im Kontext.

Ich empfehle nicht, pauschal .vscode/ zu ignorieren, weil dort oft deine reproduzierbaren Workspace‑Settings liegen (Interpreter, Test‑Setup, Format‑Konflikte).

11.2 .clinerules als Projektvertrag (damit du dich nicht wiederholen musst)
Du hast zwei Optionen:

Einzeldatei: .clinerules (schnell)

Ordner: .clinerules/ mit mehreren .md Dateien (pro‑tauglich, übersichtlich)

Ich empfehle den Ordner.

Struktur anlegen
Im Repo‑Root:

mkdir .clinerules
New-Item -ItemType File -Force `
  .clinerules\01-workflow.md, `
  .clinerules\02-python-env.md, `
  .clinerules\03-quality-gates.md, `
  .clinerules\04-safety-deps.md, `
  .clinerules\90-output-format.md
Inhalt: Copy/Paste‑Rules (bewährt für Python + Windows)
.clinerules/01-workflow.md

# Workflow (Plan/Act)

- Always start in Plan Mode for tasks touching more than 1 file.
- In Plan Mode: produce a numbered plan (max 10 steps).
  Each step must list affected files and the check to run afterwards.
- In Act Mode: implement only ONE plan step per iteration unless I explicitly allow more.
- No scope creep: if new work is discovered, return to Plan Mode and update the plan.
.clinerules/02-python-env.md

# Python Environment (Windows)

- Assume Windows + PowerShell.
- Never edit anything inside .venv/ and never read ignored files.
- Use the project venv executables explicitly when running commands:
  - .\.venv\Scripts\python.exe
  - .\.venv\Scripts\ruff.exe
- Preferred quality gate command:
  - .\scripts\check.ps1
- If interpreter confusion occurs, first run:
  - .\.venv\Scripts\python.exe -c "import sys; print(sys.executable)"
.clinerules/03-quality-gates.md

# Quality Gates

- New behavior requires tests.
- Bug fixes require a regression test (would fail before fix).
- Before claiming "done", always propose running:
  - .\scripts\check.ps1
- If the gate fails: fix ONLY what is needed to make it pass. No other improvements.
.clinerules/04-safety-deps.md

# Safety & Dependencies

- Do not add new dependencies unless I explicitly approve.
- Do not change configuration files (pyproject.toml, CI, pre-commit) without asking first.
- Never store or print secrets.
- Only operate within the workspace; do not access files outside the repo.
.clinerules/90-output-format.md

# Output Format (for transparency)

After each Act Mode step:
1) List exactly which files changed.
2) Summarize what changed in 3-6 bullets.
3) Propose exactly ONE command to run next (usually .\scripts\check.ps1).
4) If errors occur: quote only the relevant error section and propose the minimal fix.
Pro‑Hinweis: Halte Rules kurz und konfliktfrei. Wenn du dich zweimal beim selben Punkt wiederholen musst („keine Neben‑Refactors“, „lauf check.ps1“), gehört es in die Rules.

11.3 Memory Bank einführen (Langzeitgedächtnis im Repo)
Wenn du mehrere Sessions, Features oder Refactors hast, lohnt sich die Memory Bank sofort.

Struktur anlegen
mkdir memory-bank
New-Item -ItemType File -Force `
  memory-bank\projectbrief.md, `
  memory-bank\productContext.md, `
  memory-bank\activeContext.md, `
  memory-bank\systemPatterns.md, `
  memory-bank\techContext.md, `
  memory-bank\progress.md
Templates (kurz, aber maximal nützlich)
memory-bank/projectbrief.md

# Project Brief
- Purpose:
- Scope (what it does):
- Non-goals:
- Definition of Done (summary):
memory-bank/techContext.md (wichtigste Datei)

# Tech Context (Windows)

- OS: Windows, shell: PowerShell
- Python: 3.xx
- Venv: .venv/ in repo root
- Quality gate:
  - .\scripts\check.ps1
- Key commands:
  - .\.venv\Scripts\python.exe -m pip install -U ruff pytest
- Testing:
  - pytest, tests in /tests
- Lint/format:
  - Ruff configured in pyproject.toml
memory-bank/systemPatterns.md

# System Patterns
- Repo layout:
- Where core logic lives:
- Where IO/CLI lives:
- Error handling conventions:
- Public APIs that must not break:
memory-bank/activeContext.md

# Active Context
- Current goal:
- Current branch:
- Next 1-3 steps:
- Open questions/risks:
memory-bank/progress.md

# Progress
## Done
- ...

## In progress
- ...

## Next
- ...

## Known issues / tech debt
- ...
productContext.md kannst du kurz halten: Zielgruppe, typische Workflows, Output‑Ansprüche.

11.4 Session‑Ritual (damit Memory wirklich wirkt)
Das ist die Routine, die du bei jedem neuen Cline‑Task machst:

Start einer Session

Cline (Plan Mode):

„Lies DEVELOPMENT.md, .clinerules/* und memory-bank/*.“

„Fass in maximal 10 Zeilen zusammen, wie du in diesem Repo arbeitest (Quality Gate, wichtige Dateien, aktuelle Ziele).“

Dann erst: Plan für die konkrete Aufgabe.

Während der Arbeit

Nach jedem Act‑Schritt: .\scripts\check.ps1

Nach jedem Commit/Meilenstein: memory-bank/progress.md und activeContext.md aktualisieren lassen (kurz!).

Wenn es „driftet“

Neuer Task, mit kurzem Zusammenfassungs‑Prompt:

„Schreibe 8 Zeilen Status in memory-bank/activeContext.md und progress.md und starte dann mit einem frischen Plan.“

So hältst du den Chat klein, aber das Projektwissen groß.

Ergebnis von Punkt 11
Wenn Punkt 11 steht, hast du ein Repo, das Cline dauerhaft gut „führt“:

.clineignore verhindert Kontextmüll

.clinerules erzwingt Arbeitsweise + Grenzen

memory-bank/ hält Architektur/Commands/Status stabil über Sessions

Wenn du „Weiter“ schreibst, mache ich mit Punkt 12: Einsatz im echten Repo + Troubleshooting‑Leiter weiter (Branch‑Workflow, PR‑Texte, Konflikte, und eine kurze Diagnose‑Checkliste für Windows/Cline/Terminal/venv).

Du:
Weiter 
ChatGPT:
Reasoned for 4m 38s
Punkt 12: Einsatz im echten Repo + Troubleshooting‑Leiter (Windows / VS Code / Cline / Python)
Ziel dieses Punkts: Du setzt den ganzen Workflow jetzt „in echt“ ein – mit Branches, kleinen Commits, PR‑Texten, konfliktarmem Arbeiten – und du hast eine kurze, zuverlässige Fehlerleiter für die typischen Windows-/Cline‑Probleme (Interpreter, venv, Terminal‑Output, Quoting).

12.1 Der Standard‑Flow im echten Repo (Issue → Branch → Plan → Act → Gate → PR)
1) Branch pro Aufgabe

git checkout main
git pull
git checkout -b feature/<kurz>   # oder fix/<kurz>
2) Baseline prüfen (wichtig)
Bevor Cline irgendwas macht:

.\scripts\check.ps1
Wenn das schon rot ist: erst Baseline fixen (sonst debuggt Cline später „falsche Ursachen“).

3) Cline Plan Mode
Prompt‑Template:

Plan Mode.
Ziel: …
Akzeptanzkriterien: …
Nicht‑Ziele: …
Lies nur die relevanten Dateien (ich verlinke sie) und erstelle einen Plan (max 10 Schritte).
Jeder Schritt: betroffene Dateien + danach .\scripts\check.ps1.
Keine Änderungen.

4) Plan prüfen und härten
Du prüfst vor allem:

Ist der Plan in kleine Schritte teilbar?

Gibt es Tests/Regressionen?

Wird Scope sauber begrenzt?

Gibt es Konfig‑Änderungen? (nur mit Absprache)

5) Cline Act Mode, strikt in Mini‑Schritten
Prompt‑Template:

Act Mode. Implementiere ausschließlich Schritt 1 aus dem Plan.
Keine Neben‑Refactors, keine neuen Dependencies.
Danach: führe .\scripts\check.ps1 aus (erst nach meiner Freigabe).

6) Nach jedem grünen Block: Commit

git status
git add -A
git commit -m "feat: <kurz und konkret>"
7) PR vorbereiten
Wenn alles grün und sinnvoll geschnitten ist: PR erstellen.

12.2 Commit‑Disziplin (damit KI‑Änderungen reviewbar bleiben)
Praktische Regeln, die sich bewähren:

Ein Commit soll idealerweise eine logische Änderung enthalten:

„Core‑Funktion + Tests“

„CLI‑Flag + Tests“

Wenn Cline einen größeren Diff produziert:

Zurückrollen (Checkpoint oder Git restore)

In kleineren Schritten neu machen

Keine „Reformatierung des ganzen Repos“ in einem Feature‑Commit.

Commit‑Message‑Schema (einfach und effektiv):

feat(core): ...

fix(cli): ...

test: ...

chore: ...

12.3 PR‑Text automatisch erzeugen lassen (ohne Ownership abzugeben)
PR‑Beschreibung schreiben lassen (Plan Mode):

Plan Mode.
Schreibe eine PR‑Beschreibung mit: Motivation, Änderungen (bullets), Tests (wie ausgeführt), Risiken/Notes.

Review‑Checkliste für dich (5 Minuten)

Passt das Verhalten zu den Akzeptanzkriterien?

Sind Tests sinnvoll (würden sie wirklich failen, wenn es kaputt ist)?

Wurde Scope eingehalten (keine „Nebenarbeiten“)?

Ist .\scripts\check.ps1 grün?

Sind Änderungen gut geschnitten (nicht ein riesiger KI‑Commit)?

12.4 Merge‑Konflikte sauber lösen (Cline als Helfer, nicht als Umbauer)
Wenn Konflikte auftreten:

Status checken:

git status
Konfliktdateien gezielt an Cline geben und Scope einschränken:

Act Mode.
Löse ausschließlich die Merge‑Konfliktmarker in diesen Dateien.
Keine weiteren Refactors, keine Umbenennungen.
Danach: .\scripts\check.ps1.

Nach dem Fix:

git add -A
git commit -m "chore: resolve merge conflicts"
Wenn check.ps1 danach rot ist: minimal fixen, nicht „architektonisch aufräumen“.

12.5 Refactor‑Sprints im echten Repo (kontrolliert statt chaotisch)
Refactors sind der häufigste Ort, wo Agenten „zu viel“ tun. So bleibt es stabil:

Refactor‑Spezifikation (du gibst das immer mit):

Ziel: Was wird verbessert?

Constraints:

Public API unverändert

Verhalten unverändert

Tests müssen nach jedem Schritt grün sein

Plan in Phasen:

Phase 1: mechanische Umstrukturierung

Phase 2: Vereinheitlichung/Naming (nur wenn nötig)

Phase 3: Performance/Feinschliff (optional)

Prompt (Plan Mode):

Plan Mode. Refactor‑Ziel: …
Constraints: keine API‑Änderung, Verhalten muss identisch bleiben.
Plane in Phasen, jeder Schritt muss nach .\scripts\check.ps1 grün sein.

Troubleshooting‑Leiter (Windows): schnell zur Ursache
Wenn etwas „komisch“ ist, geh exakt so vor (Reihenfolge zählt).

12.6 Stufe 1: Harte Fakten sammeln (2 Minuten)
Im Repo‑Root:

git status
.\.venv\Scripts\python.exe -c "import sys; print(sys.executable)"
.\.venv\Scripts\python.exe -m pip --version
.\scripts\check.ps1
Was du damit klärst:

Working tree sauber oder nicht?

Nutzt du wirklich die Repo‑venv?

Ist das Quality Gate reproduzierbar rot oder grün?

12.7 Stufe 2: „Falsche venv / falsches Python“ (häufigster Fehler)
Symptome:

pytest findet Pakete nicht

ruff wird nicht gefunden

Verhalten ist „anders als gestern“

Fix‑Prinzip:

Nutze konsequent venv‑Executables:

.\.venv\Scripts\python.exe …

.\.venv\Scripts\ruff.exe …

In VS Code: Interpreter neu wählen (Python: Select Interpreter) und .venv setzen.

12.8 Stufe 3: Cline kann Terminal‑Output nicht lesen / hängt
Symptome:

Cline wartet ewig auf Output

Commands laufen, aber Cline „sieht“ das Ergebnis nicht

Fix‑Schritte:

VS Code neu starten

In Cline Settings: Terminal Execution Mode auf Background Exec

Wenn Commands mit vielen Anführungszeichen scheitern:

Keine Inline‑Kommandos mit komplexem Quoting verwenden

Stattdessen Skripte ausführen (.\scripts\check.ps1), oder ein temporäres .py Script statt python -c "..."

12.9 Stufe 4: Quoting‑Probleme (Windows‑Kante)
Symptome:

python -c "..." oder ähnliche Befehle brechen nur unter Cline/Background Exec

Ausgaben wirken „escaped“ oder zerschossen

Stabiler Workaround:

Schreib Diagnosen in eine Datei:

scripts/diag.py und dann .\.venv\Scripts\python.exe scripts\diag.py

Halte Cline‑Commands „quote‑arm“:

Lieber .\scripts\check.ps1 als lange, gequotete Einzeiler

12.10 Stufe 5: Performance / „Cline wird unpräzise“
Symptome:

Cline liest zu viel

Antworten werden unsauber, Scope driftet

Fix‑Prinzip:

.clineignore erweitern (Caches, Builds, Datenfiles, Logs)

Aufgaben kleiner schneiden (max 1–3 Dateien pro Iteration)

Neuen Task starten und Status in memory-bank/activeContext.md / progress.md festhalten

Diagnose‑Prompt (Copy/Paste für Cline)
Wenn du willst, dass Cline sich strukturiert selbst debuggt (am besten in Plan Mode):

Plan Mode. Diagnose unter Windows.
Ziel: herausfinden, warum Tool‑Runs/venv/Terminal nicht korrekt funktionieren.

Nenne die 3 wichtigsten Checks, die du als erstes machen willst.

Gehe davon aus, dass die Wahrheit .\scripts\check.ps1 ist.

Wenn du Commands vorschlägst: nutze ausschließlich .venv\\Scripts\\python.exe und .\scripts\check.ps1.

Erstelle danach einen Fix‑Plan in max 6 Schritten. Keine Codeänderungen.

Ergebnis von Punkt 12
Wenn Punkt 12 sitzt, kannst du Cline in echten Repos produktiv einsetzen, ohne Kontrolle zu verlieren:

Branch‑basiert, reviewbar, kleine Commits

Plan/Act als Standardritual

check.ps1 als objektive Wahrheit

Merge‑Konflikte und Refactors kontrolliert

Windows‑Troubleshooting als kurze, reproduzierbare Leiter

Wenn du als nächstes möchtest, kann ich dir aus diesen 12 Punkten auch eine noch kürzere „Daily Routine“ (10 Zeilen) formulieren, die du dir oben in DEVELOPMENT.md als Reminder hinpackst.

Du:
Ja
ChatGPT:
Reasoned for 2m 19s
Hier ist eine kompakte Daily Routine (10 Zeilen), die du ganz oben in DEVELOPMENT.md einfügen kannst:

## Daily Routine (Cline + Python, Windows)

1) Repo öffnen (C:\dev\projects\...), `git status` prüfen (clean bevorzugt).
2) In Feature-Branch wechseln/erstellen.
3) Baseline: `.\scripts\check.ps1` (muss grün sein, bevor KI ändert).
4) Cline starten → Plan Mode: Ziel + Akzeptanz + Nicht-Ziele → Plan (max 10 Schritte).
5) Plan prüfen (Scope, Tests, Risiken). Erst dann Act Mode.
6) Act Mode: immer nur 1 Plan-Schritt umsetzen lassen (keine Neben-Refactors).
7) Nach jedem Schritt: `.\scripts\check.ps1` (rot → minimal fixen, keine Extras).
8) Wenn grün: kleiner Commit (logisch geschnitten).
9) Wenn Kontext/Scope driftet: Plan Mode, Plan nachschärfen oder neuer Task + Status in memory-bank.
10) PR: Cline schreibt PR-Text, du machst Review + finaler `.\scripts\check.ps1`.




Gut – ich habe die Punkte ab 13 nochmal „kritisch“ durchdacht (Risiken: README wird versehentlich kaputt‑ersetzt, Template‑Name wird in Anleitungen überschrieben, zu invasive Paket‑Renames, zu viel Global-Search/Replace). Daraus habe ich einen saubereren Ablauf gemacht, der zu deiner gewählten Option passt:

 

Gewählte Option (Startstandard): devproj bleibt überall gleich. Bootstrap passt nur Projektname/Docs/Memory an (plus optional venv + Tools + Quality Gate). Kein Paket‑Rename, keine Import‑Änderungen.

 

Unten bekommst du:

Einen Überblick aller neuen Punkte (damit der Ablauf klar ist)

Punkt 13 vollständig (so kannst du ihn 1:1 an Cline geben)

Die Schritte, die Cline typischerweise nicht sauber/zuverlässig erledigen kann (GitHub Web‑Settings, Template‑Haken setzen), kommen bewusst am Ende.

Überblick: neue Punkte ab Punkt 13 (für euren Ablauf)

Punkt 13 – Template‑Repo “entpersonalisieren” und vorbereiten
Alt‑Namen/Pfade entfernen, Template‑Identität klar machen, Platzhalter python-cline-template dort einführen, wo Bootstrap später zuverlässig greifen soll (Memory Bank + ggf. README‑Vorlage). Keine Codeänderungen an devproj.

 

Punkt 14 – Bootstrap‑Script als Standard einbauen
scripts/bootstrap.ps1 erzeugen: Projektname aus Ordnername, nur Textdateien anfassen, Platzhalter ersetzen, optional .venv + ruff/pytest + check.ps1. Keine .py Änderungen.

 

Punkt 15 – CI hinzufügen (GitHub Actions)
.github/workflows/ci.yml: Ruff + pytest laufen bei push/PR, damit jedes abgeleitete Repo sofort Qualitätschecks hat.

 

Punkt 16 – “Template Usage” Dokumentation finalisieren
Kurze, eindeutige Doku: „Use this template → clone → bootstrap → check → commit“. Optional: BOOTSTRAP.md oder TEMPLATE_USAGE.md.

 

Punkt 17 – Pre‑Publish Self‑Test lokal
Ohne GitHub: Repo in neuen Ordner kopieren, Bootstrap laufen lassen, check grün, sicherstellen dass nur die erwarteten Dateien geändert werden.

 

Punkt 18 – Manuelle GitHub‑Schritte (nicht für Cline)
Repo python-cline-template publishen, Template‑Haken setzen, Test über „Use this template“ auf GitHub.

Punkt 13: Template‑Repo entpersonalisieren und vorbereiten (für Cline)
Ziel

Dein aktuelles Repo in C:\dev\projects\python-cline-template soll als sauberes GitHub Template Repo funktionieren, ohne alte lokale Namen/Pfade. Gleichzeitig soll Bootstrap später zuverlässig “andocken” können, ohne dass README/Anleitungen zerstört werden.

Warum dieser Punkt wichtig ist (Fehler, die wir vermeiden)

Globales Ersetzen von Repo‑Name kann Anleitungen kaputt machen (“python-cline-template” soll im Template‑README stehen bleiben).

Wenn der Template‑Name noch überall als alter Pfad steht (C:\dev\projects\python-cline-template), wird jedes neue Projekt “falsch beschriftet”.

Bootstrap braucht stabile Anker: Platzhalter in Memory‑Bank sind viel robuster als “Suche nach altem Namen”.

Deliverables (was am Ende existieren/korrekt sein muss)

Keine hartcodierten Pfade/Alt‑Namen mehr in projektinternen Kontextdateien (Memory Bank, TechContext etc.).

Memory‑Bank Dateien enthalten an sinnvollen Stellen python-cline-template (damit Bootstrap später sicher ersetzen kann).

Ein README‑Setup, das Template klar erklärt, ohne sich selbst zu „personalisieren“.

.\scripts\check.ps1 bleibt grün.

Akzeptanzkriterien

.\scripts\check.ps1 läuft grün (nach Änderungen).

Repo‑Suche nach python-cline-template findet keine Treffer mehr (oder nur noch in einer historischen Changelog‑Notiz, falls du sowas bewusst behältst).

Repo‑Suche nach C:\dev\projects\python-cline-template findet keine Treffer.

devproj/ bleibt unverändert (keine Rename‑Aktion, keine Import‑Änderungen).

Prompt für Cline (Punkt 13)

Kopiere das in Cline Plan Mode:

Punkt 13 – Template Repo vorbereiten (Plan Mode)
Ziel: Das Repo wird ein GitHub Template (python-cline-template), ohne alte lokale Namen/Pfade. Wir verwenden die Option: Python-Paket bleibt devproj, keine Code-/Import-Renames.

 

Bitte mache zuerst nur eine Analyse und erstelle einen Plan (max 8 Schritte), dann liste genau auf:

Wo kommt python-cline-template noch vor?

Wo kommt der harte Pfad C:\dev\projects\python-cline-template oder ähnliche lokale Pfade vor?

In welchen memory-bank/*.md Dateien sollen wir python-cline-template als Platzhalter einführen, damit ein späteres Bootstrap-Skript zuverlässig den Projektnamen setzen kann?

Welche README-Änderungen sind sinnvoll, damit das Repo als Template erklärt wird (ohne später beim Bootstrap “falsch” ersetzt zu werden)?

Constraints:

Keine Änderungen an Python-Code (*.py) in Punkt 13

devproj bleibt unverändert

Änderungen nur an Doku/Markdown/TOML/JSON/YAML, wenn nötig

Am Ende: gib mir den Plan + eine Datei-Liste (welche Dateien du ändern würdest).

Wenn Cline den Plan gezeigt hat und du zufrieden bist, wechselst du auf Act Mode und gibst:

Punkt 13 – Umsetzung (Act Mode)
Setze den Plan um. Keine Änderungen an *.py.
Danach führe .\scripts\check.ps1 aus (erst nach meiner Freigabe).
Zum Schluss: kurze Zusammenfassung + Liste der geänderten Dateien.

Hinweis: Was Cline hier nicht machen muss/kann

Nichts in GitHub anklicken. Keine Repo‑Erstellung. Kein Template‑Haken. Das kommt erst ganz am Ende (Punkt 18, manuell).

Wenn du „Weiter“ schreibst, gebe ich dir Punkt 14 (Bootstrap‑Script als Standard, robust und bewusst nur für Textdateien/Memory/Docs, plus optional venv+Tools+check).

weiter
Thought for 1m 30s
Punkt 14: Bootstrap‑Script als Standard einbauen
Ziel

Nach „Use this template“ + Clone soll der Nutzer im neuen Repo nur noch ausführen:

.\scripts\bootstrap.ps1 -SetupVenv


Und danach:

Projektname/Docs/Memory passen zum Ordnernamen (oder Parameter),

devproj bleibt unverändert,

optional wird .venv erstellt, ruff/pytest installiert und .\scripts\check.ps1 läuft.

Warum dieser Punkt wichtig ist (kritische Hinterfragung)

Wir wollen vermeiden, dass das Script:

versehentlich Python‑Code oder Imports verändert (deshalb keine .py Ersetzung),

Anleitungen kaputt ersetzt („python-cline-template“ soll im Template‑README stehen bleiben),

durch „Suche nach altem Projektnamen“ fragil wird.

Deshalb setzen wir auf:

Platzhalter python-cline-template in Memory/Doku (stabil),

und nur als Fallback: Ersetzen alter/historischer Namen, aber sehr gezielt.

Deliverables

Datei: scripts/bootstrap.ps1 existiert und ist dokumentiert.

Bootstrap ersetzt nur Textdateien (.md/.txt/.toml/.json/.yml/.yaml).

Bootstrap ignoriert .git/, .venv/, Caches.

Optionaler Setup‑Pfad: .venv erstellen, Tools installieren, check.ps1 laufen lassen.

README erklärt den Standard‑Flow klar.

Akzeptanzkriterien

In einem frisch geklonten Repo führt .\scripts\bootstrap.ps1 zu nur erwarteten Änderungen (Docs/Memory), keine .py Änderungen.

Mit -SetupVenv läuft am Ende .\scripts\check.ps1 grün (wenn das Projekt baseline grün ist).

Script läuft ohne Adminrechte in PowerShell.

Prompt für Cline (Punkt 14)
14A – Plan Mode

Kopiere in Cline Plan Mode:

Punkt 14 – Bootstrap Script (Plan Mode)
Ziel: scripts/bootstrap.ps1 als Standard-Bootstrap für Template-Repos.
Gewählte Option: Python-Paket bleibt devproj (keine Code-Renames, keine Import-Renames).

 

Anforderungen an bootstrap.ps1:

ProjectName default = Ordnername des Repo-Root

Nur Textdateien anfassen: .md, .txt, .toml, .json, .yml, .yaml

In Textdateien python-cline-template durch ProjectName ersetzen

Ignoriere: .git/, .venv/, pycache/, .pytest_cache/, .ruff_cache/

Optionaler Schalter -SetupVenv:

erstellt .venv, aktualisiert pip, installiert ruff+pytest (oder requirements-dev.txt), dann führt scripts/check.ps1 aus

Das Script soll am Ende eine kurze “Next steps” Ausgabe drucken

Bitte erstelle einen Plan (max 6 Schritte) und liste:

Welche Datei(en) du anlegst/änderst (bootstrap.ps1, README ggf.)

Welche Strings du NICHT ersetzen wirst (z. B. "python-cline-template" in Template-Anleitungen) und wie du das sicherstellst

Wie du sicherstellst, dass keine *.py Dateien geändert werden

Keine Änderungen ausführen, nur Plan.

14B – Act Mode Umsetzung

Wenn Plan ok, dann in Act Mode:

Punkt 14 – Umsetzung (Act Mode)
Erstelle/ändere die Dateien gemäß Plan:

scripts/bootstrap.ps1

README.md (falls nötig, kurze Template-Nutzung)

Constraints:

Keine Änderungen an *.py

Keine Änderungen an scripts/check.ps1 außer du erklärst zwingend warum

Danach: schlage mir vor, welche Commands ich ausführen soll, um zu testen (bootstrap ohne SetupVenv und bootstrap mit SetupVenv). Führe sie erst nach meiner Freigabe aus.
Zum Schluss: Liste der geänderten Dateien.

Nutzer‑Test (das machst du danach, nicht Cline)

Nach der Umsetzung testest du lokal im Repo:

Test 1: Bootstrap ohne venv‑Setup (soll nur Docs/Memory anfassen)
.\scripts\bootstrap.ps1 -NonInteractive
git status

Test 2: Bootstrap mit SetupVenv (soll venv + Tools + check machen)
.\scripts\bootstrap.ps1 -SetupVenv -NonInteractive


Wichtig: Wenn .venv existiert, ist das ok lokal – aber sie darf nicht getrackt werden.

Hinweis: Was wir bewusst NICHT tun

Kein automatisches Umbenennen von devproj

Kein Ersetzen in .py

Kein “smartes” Refactoring. Bootstrap ist nur Initialisierung.

Wenn du „Weiter“ schreibst, kommt Punkt 15: GitHub Actions CI hinzufügen (workflow Datei, so dass neue Projekte aus dem Template sofort automatische Checks bekommen).

weiter
Thought for 1m 17s
Punkt 15: GitHub Actions CI hinzufügen (automatisches Quality Gate auf GitHub)
Ziel

Dein Template‑Repo (und jedes daraus erzeugte Repo) hat sofort CI: bei jedem Push/PR laufen Ruff + pytest automatisch. Das macht die Vorlage professionell und verhindert, dass man lokal „vergisst“ zu testen.

 

Wir bauen CI so, dass sie:

auf Ubuntu schnell prüft (ruff + pytest),

optional auch auf Windows zusätzlich prüft, dass scripts/check.ps1 wirklich funktioniert.

Kritische Hinterfragung (damit wir keine Fehler einbauen)

CI darf nicht von deiner lokalen .venv abhängen → CI erstellt eine frische Umgebung.

scripts/check.ps1 nutzt .venv\Scripts\... → auf Windows‑Runner müssen wir deshalb .venv explizit erstellen.

Auf Linux gibt es kein .venv\Scripts\... → dort lieber direkt python -m ....

Wir müssen sicherstellen, dass CI in einem neuen Projekt aus der Vorlage ohne weitere Anpassungen läuft:

wenn requirements-dev.txt existiert → installiere daraus,

sonst installiere ruff + pytest minimal.

Deliverables

Datei: .github/workflows/ci.yml

CI läuft auf Push und PR

CI ist grün (sofern lokal check.ps1 grün ist)

Akzeptanzkriterien

ci.yml ist im Repo und committed.

Ein Push triggert Actions.

CI läuft mindestens unter Ubuntu (empfohlen) – optional zusätzlich Windows.

Bei einem absichtlichen Testfehler wird CI rot.

Prompt für Cline (Punkt 15)
15A – Plan Mode

Kopiere in Cline Plan Mode:

Punkt 15 – GitHub Actions CI (Plan Mode)
Ziel: .github/workflows/ci.yml hinzufügen.
CI soll laufen auf:

ubuntu-latest (ruff + pytest)

optional windows-latest (erstellt .venv, führt scripts/check.ps1 aus)

Requirements:

nutze Python 3.12

installiere Abhängigkeiten aus requirements-dev.txt, wenn vorhanden, sonst installiere ruff und pytest

keine Verwendung von lokaler .venv

triggers: push, pull_request, workflow_dispatch

Bitte gib einen Plan (max 4 Schritte) + den vollständigen YAML-Inhalt, den du anlegen willst. Keine Änderungen ausführen.

15B – Act Mode Umsetzung

Wenn Plan ok, dann in Act Mode:

Punkt 15 – Umsetzung (Act Mode)
Lege .github/workflows/ci.yml gemäß Plan an.
Danach: liste die geänderten Dateien.
Keine weiteren Änderungen.

Empfohlener Workflow‑Inhalt (als Zielbild)

Wenn Cline fragt „soll Windows‑Job rein?“:
Ja, ich empfehle es, weil dein Template Windows‑optimiert ist (check.ps1). Das ist „pro“, und die Kosten sind gering.

 

Das Ziel‑ci.yml soll in etwa so aussehen (Cline kann es 1:1 übernehmen):

name: CI

on:
  push:
  pull_request:
  workflow_dispatch:

permissions:
  contents: read

jobs:
  quality:
    name: Quality Gate (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          cache: "pip"
          cache-dependency-path: |
            requirements-dev.txt
            requirements.txt
            pyproject.toml

      - name: Install deps (Linux)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          python -m pip install -U pip
          if [ -f requirements-dev.txt ]; then
            python -m pip install -r requirements-dev.txt
          else
            python -m pip install -U ruff pytest
          fi

      - name: Quality Gate (Linux)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          python -m ruff check .
          python -m ruff format --check .
          python -m pytest

      - name: Setup venv + deps (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          py -m venv .venv
          .\.venv\Scripts\python.exe -m pip install -U pip setuptools wheel
          if (Test-Path "requirements-dev.txt") {
            .\.venv\Scripts\python.exe -m pip install -r requirements-dev.txt
          } else {
            .\.venv\Scripts\python.exe -m pip install -U ruff pytest
          }

      - name: Quality Gate (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: .\scripts\check.ps1

Was Cline nicht kann / was du danach machen musst

Cline kann die Datei anlegen und committen.

Ausführen der GitHub Actions passiert erst nach Push.

Den „Actions“ Tab prüfen machst du im Browser oder VS Code.

Danach (du, Nutzer)

Wenn Cline fertig ist:

git status
git add -A
git commit -m "ci: add GitHub Actions quality gate"


Wenn du „Weiter“ schreibst, kommt Punkt 16: Doku finalisieren (kleines TEMPLATE_USAGE.md oder BOOTSTRAP.md + README‑Abschnitt so, dass Bootstrap nicht versehentlich die Template‑Anleitung zerstört).

weiter
Thought for 1m 12s
Punkt 16: Doku finalisieren (Template Usage + Bootstrap Usage, ohne “kaputt ersetzt” zu werden)
Ziel

Jeder (auch du in ein paar Wochen) versteht sofort:

Repo ist ein Template

Wie man daraus ein neues Projekt erzeugt

Welche Option gilt: devproj bleibt

Welche Commands sind Standard (bootstrap.ps1, check.ps1)

Was nach Bootstrap zu committen ist

Gleichzeitig vermeiden wir, dass Bootstrap aus Versehen die Template‑Anleitung „umbenennt“ oder unlesbar macht.

Kritische Hinterfragung

Wenn Bootstrap blind Template‑Strings ersetzt, kann es die README‑Anleitung verändern.
Das vermeiden wir so:

Wir schreiben in der Template‑Doku nicht „python-cline-template“, sondern nutzen Platzhalter:

python-cline-template

Und wir halten Template‑Doku bewusst generisch (nicht „python-cline-template überall“), sondern:

„Dieses Repo ist eine Vorlage…“

Damit kann Bootstrap problemlos python-cline-template ersetzen, ohne “eigene Identität” zu zerstören.

Deliverables

README enthält eine kurze „Use this template“ Sektion

Neue Datei TEMPLATE_USAGE.md (oder BOOTSTRAP.md) erklärt den Ablauf in 10–20 Zeilen

Memory Bank: projectbrief.md und activeContext.md sind als Template formuliert und enthalten python-cline-template (oder zumindest keine alten Namen)

Akzeptanzkriterien

Doku ist kurz, eindeutig, ohne lokale Pfade.

Bootstrap verändert Doku sinnvoll (setzt ProjectName), aber zerstört sie nicht.

.\scripts\check.ps1 bleibt grün.

Prompt für Cline (Punkt 16)
16A – Plan Mode

In Cline Plan Mode:

Punkt 16 – Template-Dokumentation (Plan Mode)
Ziel: Dokumentation so gestalten, dass das Repo als Template funktioniert.
Option: devproj bleibt überall gleich. Bootstrap passt nur Projektname/Docs/Memory an.

 

Bitte plane (max 6 Schritte):

Welche README-Änderung nötig ist (kurz, 8–12 Zeilen).

Ob eine extra Datei TEMPLATE_USAGE.md oder BOOTSTRAP.md sinnvoll ist (eine wählen).

Welche Memory-Bank Dateien als Template formuliert werden sollen, inkl. python-cline-template.

Constraints:

Keine Änderungen an *.py

Keine langen Texte; alles kurz und kopierbar

Liefere mir am Ende:

den finalen Textblock für README

den kompletten Inhalt für die neue Datei

welche Memory-Dateien du anpassen würdest

16B – Act Mode Umsetzung

Wenn Plan ok, dann Act Mode:

Punkt 16 – Umsetzung (Act Mode)
Setze den Plan um: README anpassen, neue Datei anlegen (wie geplant), Memory-Bank aktualisieren.
Keine *.py Änderungen.
Danach: Liste der geänderten Dateien. Keine weiteren Aktionen.

Konkreter Zieltext, den du erwartest (als Orientierung)
README‑Block (kurz)
## Use this template

Standard option (recommended start):
- The Python package name stays `devproj`.
- Bootstrap adapts only project name / docs / memory.

Steps after creating a repo from this template and cloning it:
1) .\scripts\bootstrap.ps1 -SetupVenv
2) .\scripts\check.ps1
3) git add -A && git commit -m "chore: bootstrap project"

TEMPLATE_USAGE.md (sehr kurz)
# Template usage

This repository is a template for Python + VS Code + Cline on Windows.

Standard option:
- Keep Python package name `devproj` unchanged.
- Bootstrap updates project name in docs/memory and can set up the venv.

After cloning a new repo:
1) .\scripts\bootstrap.ps1 -SetupVenv
2) .\scripts\check.ps1
3) Commit bootstrap changes

If you only want doc updates:
- .\scripts\bootstrap.ps1

Danach (du, Nutzer)

Nach Cline:

git add -A
git commit -m "docs: add template usage documentation"


Wenn du „Weiter“ schreibst, kommt Punkt 17: Pre‑Publish Self‑Test lokal (wir simulieren „Use this template“ ohne GitHub, damit du vor dem Publish sicher bist, dass Bootstrap und Doku genau so funktionieren wie geplant).

weiter
Thought for 1m 5s
Punkt 17: Pre‑Publish Self‑Test lokal (Template‑Flow ohne GitHub simulieren)
Ziel

Bevor du das Repo auf GitHub als Template veröffentlichst, willst du sicher wissen:

Bootstrap funktioniert in einem „frischen Klon“‑Szenario

Es werden nur Docs/Memory angepasst (keine .py)

-SetupVenv macht .venv + Tools + check.ps1

Nichts Unerwartetes wird geändert oder kaputt ersetzt

Das ist der wichtigste Qualitätsschritt, weil er dir spätere Frustration erspart.

Kritische Hinterfragung

Viele Template‑Repos wirken erst „fertig“, bis man sie wirklich einmal in einen neuen Ordner legt und bootstrap ausführt. Typische Fehler, die hier auffallen:

Script arbeitet relativ zu falschem Pfad

Script ersetzt zu viel (z. B. Template‑Anleitung)

Script findet requirements-dev.txt nicht

.venv wird versehentlich getrackt

Änderungen landen in .py obwohl sie nicht sollen

Deliverables

Ein lokaler „Simulations‑Ordner“, in dem du das Template einmal durchspielst

Ein klarer Testablauf (2 Varianten: ohne SetupVenv, mit SetupVenv)

Ein kurzer Nachweis: welche Dateien wurden geändert

Akzeptanzkriterien

bootstrap.ps1 ohne SetupVenv ändert nur Textdateien.

bootstrap.ps1 -SetupVenv erstellt .venv und check.ps1 läuft grün.

git status zeigt keine .venv‑Dateien als „tracked“.

Keine .py Files sind im Diff.

Dieser Punkt ist Nutzer‑Arbeit (nicht für Cline)

Cline kann die Testschritte vorschlagen, aber du solltest das selbst im Terminal ausführen, weil es echte Dateikopien/Ordner betrifft.

17.1 Test‑Ordner vorbereiten

Wir simulieren „neues Projekt aus Template“ durch eine Kopie in einen neuen Ordner.

 

Wähle einen Testnamen, z. B.:

C:\dev\projects\_template_selftest_1

17.2 Template in neuen Ordner kopieren (ohne .git und .venv)

Am zuverlässigsten ist Robocopy:

$src = "C:\dev\projects\python-cline-template"
$dst = "C:\dev\projects\_template_selftest_1"

robocopy $src $dst /E /XD ".git" ".venv" "__pycache__" ".pytest_cache" ".ruff_cache" ".mypy_cache" > $null

17.3 In den Testordner wechseln und Git initialisieren
cd C:\dev\projects\_template_selftest_1
git init
git add -A
git commit -m "chore: init selftest copy"

17.4 Test 1: Bootstrap ohne SetupVenv (nur Docs/Memory)
.\scripts\bootstrap.ps1 -NonInteractive
git status


Erwartung:

Es gibt Änderungen in README.md, TEMPLATE_USAGE.md (oder BOOTSTRAP.md), memory-bank/*

Keine Änderungen in *.py

Prüfe explizit:

git diff --name-only | findstr /I "\.py"


Soll: keine Ausgabe.

17.5 Test 2: Bootstrap mit SetupVenv
.\scripts\bootstrap.ps1 -SetupVenv -NonInteractive


Dann:

.\scripts\check.ps1

17.6 Sicherstellen, dass .venv nicht in Git gelandet ist
git status
git ls-files | findstr /I ".venv"


Soll: .venv erscheint nicht in ls-files.

17.7 Self‑Test Ergebnis dokumentieren (optional, aber hilfreich)

Wenn alles passt, ist gut.
Wenn nicht: du hast sofort klare Fehlerstellen (meist im Bootstrap‑Script oder in zu aggressiven Ersetzungen).

Wenn etwas schiefgeht: typische Fixes

Bootstrap ändert .py → Script muss .py strikt ausschließen (Filter prüfen)

Bootstrap ersetzt „zu viel“ im README → nutze Platzhalter python-cline-template statt Template‑Name

check.ps1 rot → fehlt requirements-dev.txt oder ruff/pytest nicht installiert → SetupVenv‑Teil prüfen

Wenn du „Weiter“ schreibst, kommt Punkt 18: Manuelle GitHub‑Schritte (Publish als python-cline-template, Template‑Haken setzen, Test über „Use this template“). Diese Schritte kann Cline nicht zuverlässig ausführen, deswegen stehen sie bewusst am Schluss.

weiter
Thought for 1m 41s
Punkt 18: Manuelle GitHub‑Schritte (Publish, Template aktivieren, End‑to‑End Test)

Diese Schritte kann Cline nicht zuverlässig „klicken“/ausführen, deshalb sind sie am Schluss und als Nutzer‑Checkliste formuliert.

18.1 Repo als python-cline-template auf GitHub veröffentlichen

Du hast zwei Wege. Da VS Code bei dir schon mit GitHub verbunden ist (User veritarium), ist Weg A am bequemsten.

Weg A: VS Code „Publish to GitHub“

Öffne in VS Code dein Template‑Repo:

C:\dev\projects\python-cline-template

Source Control (linke Seitenleiste) öffnen

Wenn noch kein Remote existiert:

Klick Publish to GitHub

Name: python-cline-template

Account: veritarium

Public/Private auswählen

Publish

Danach im Terminal prüfen:

git remote -v
git branch --show-current


Push (falls VS Code es nicht automatisch gemacht hat):

git push -u origin main

Weg B: Remote manuell setzen (falls du lieber über Git arbeitest)

GitHub im Browser → „New repository“

Name: python-cline-template

NICHT „Initialize with README“ (du hast schon eins)

Dann im Terminal:

cd C:\dev\projects\python-cline-template
git remote add origin https://github.com/veritarium/python-cline-template.git
git branch -M main
git push -u origin main

18.2 Repo als Template markieren

Auf GitHub:

Repo python-cline-template öffnen

Settings

Bereich Template repository

Haken setzen

Optional (empfohlen):

Description setzen

Topics: python, template, vscode, cline, ruff, pytest

18.3 End‑to‑End Test über „Use this template“

Jetzt testest du den echten Ziel‑Flow:

18.3.1 Neues Repo aus Template erstellen

GitHub → python-cline-template → Use this template
Repo‑Name: z. B. template-e2e-test-1

18.3.2 Lokal klonen
cd C:\dev\projects
git clone https://github.com/veritarium/template-e2e-test-1.git
cd template-e2e-test-1

18.3.3 Bootstrap ausführen (Standard‑Option: devproj bleibt)
.\scripts\bootstrap.ps1 -SetupVenv -NonInteractive

18.3.4 Bootstrap‑Änderungen committen und pushen
git add -A
git commit -m "chore: bootstrap project"
git push

18.4 CI prüfen (wenn du Punkt 15 umgesetzt hast)

Auf GitHub im Repo template-e2e-test-1:

Tab Actions öffnen

Erwartung: Workflow läuft grün

Wenn CI rot:

Logs öffnen

Meistens ist es ein fehlendes requirements-dev.txt oder ein Konfig‑Pfadproblem.

Fix kommt dann in die Template‑Repo, nicht im abgeleiteten Projekt (damit es für alle künftig passt).

18.5 Definition „fertig“ für die Template‑Einführung

Du bist mit dem ganzen Template‑Projekt fertig, wenn:

python-cline-template ist auf GitHub

Template‑Haken ist gesetzt

„Use this template“ → Clone → bootstrap.ps1 -SetupVenv → check.ps1 klappt

(optional) CI läuft grün

Was danach dein Standard‑Workflow ist (kurz)

Für jedes neue Projekt:

GitHub → Use this template

Clone nach C:\dev\projects\<neuer-name>

.\scripts\bootstrap.ps1 -SetupVenv -NonInteractive

Commit & push

Ab da: Plan/Act + .\scripts\check.ps1

Wenn du möchtest, kann ich als nächstes noch einen Punkt 19 hinzufügen: „Template‑Wartung“ (wie du Verbesserungen am Template machst, ohne bestehende Projekte zu brechen, und wie du Updates sauber in einzelne Projekte zurückportierst).

ja
Thought for 1m 21s
Punkt 19: Template‑Wartung und Updates in bestehende Projekte zurückspielen
Ziel

Du willst dein Template weiter verbessern (Scripts, Rules, CI, Doku), ohne Chaos zu erzeugen – und du willst bei Bedarf Verbesserungen in bestehende Projekte übernehmen, aber kontrolliert.

 

Wichtiges Prinzip:
Ein Template ist kein Paketmanager. Es updatet abgeleitete Repos nicht automatisch. Updates passieren bewusst und gezielt.

19.1 Was darf sich im Template ändern, ohne Projekte zu „brechen“?
Sehr safe zu ändern (empfohlen)

DEVELOPMENT.md

TEMPLATE_USAGE.md / BOOTSTRAP.md

.clinerules/* (solange sie nicht plötzlich Dinge verlangen, die alte Projekte nicht erfüllen können)

.clineignore

scripts/check.ps1 (wenn du abwärtskompatibel bleibst)

scripts/bootstrap.ps1

.github/workflows/ci.yml (für neue Projekte aus Template)

Vorsicht (kann brechen)

pyproject.toml (Lint-/Formatregeln können viele Diffs erzeugen)

Repo‑Struktur (Ordner verschieben)

Python‑Paketlayout (z. B. später doch devproj umbenennen)

„Quality Gate“ härter machen (z. B. neue zwingende Checks), wenn alte Projekte das nicht haben

Empfehlung: Alles, was viele Diffs auslöst, nur in „Major Update“-Wellen.

19.2 Versionierung für das Template (damit du weißt, was du wann genutzt hast)
Minimal (reicht oft)

Tagge Template‑Releases in Git:

v0.1-template

v0.2-template

Beispiel:

git tag v0.1-template
git push origin v0.1-template

Pro-Variante (wenn du viele Projekte hast)

Führe in der Template‑Repo eine Datei ein: TEMPLATE_VERSION.txt

Inhalt: 0.2

Bootstrap kann in neuen Projekten optional eine Datei anlegen:

TEMPLATE_USED.txt oder TEMPLATE_ORIGIN.txt

z. B. „created from python-cline-template v0.2-template“

Das ist Gold wert, wenn du später ein altes Projekt siehst und wissen willst, auf welchem Stand es gestartet ist.

19.3 Wie du Updates in ein bestehendes Projekt übernimmst (kontrolliert)
Empfohlener Workflow (immer so)

Im Zielprojekt einen Branch erstellen:

git checkout -b chore/template-sync-<datum>


Aus dem Template nur die „safe“ Dateien übernehmen (kein Code):

scripts/check.ps1

scripts/bootstrap.ps1 (optional)

.clinerules/

.clineignore

.github/workflows/ci.yml (optional)

DEVELOPMENT.md / TEMPLATE_USAGE.md (optional)

Danach:

.\scripts\check.ps1


Commit:

git add -A
git commit -m "chore: sync template tooling and rules"


PR / Merge.

19.4 Praktische Methoden, um Dateien zu übernehmen
Methode A: „Copy/Paste + Diff“ (einfach, sehr zuverlässig)

Öffne Template‑Repo und Zielprojekt nebeneinander in VS Code

kopiere Datei

nutze VS Code „Compare“ (rechtsklick) wenn du prüfen willst

Methode B: Git‑Checkout einzelner Dateien aus dem Template‑Repo (sehr sauber)

Wenn Template‑Repo als Remote hinzugefügt wird (einmalig):

git remote add template https://github.com/veritarium/python-cline-template.git
git fetch template


Dann kannst du einzelne Dateien übernehmen:

git checkout template/main -- scripts/check.ps1 .clineignore
git checkout template/main -- .clinerules
git checkout template/main -- .github/workflows/ci.yml


Das ist extrem kontrolliert: du holst nur die Dateien, die du willst.

19.5 „Policy“: Was du niemals automatisch updatest

Damit es stabil bleibt:

keine automatischen Code‑Refactors in bestehenden Projekten

kein automatisches Umbenennen von devproj in bestehenden Projekten

keine „random“ Änderungen in pyproject.toml, außer du machst bewusst einen Lint/Format‑Change und planst die Diffs ein

19.6 Typische Weiterentwicklungsschritte fürs Template (Roadmap)

Wenn du nach den ersten 3–5 Projekten merkst „immer wieder das gleiche“, sind das gute Kandidaten fürs Template:

scripts/check.ps1 erweitert um optional:

python -m pip check

Coverage

pre-commit Integration (als optionaler Standard)

Makefile Ersatz für Windows (z. B. scripts/tasks.ps1)

CI schneller machen (Cache optimieren)

„Project init“ verbessern:

Bootstrap schreibt memory-bank/projectbrief.md initial mit Projektname

Bootstrap setzt progress.md auf „Initialized“

Alles weiterhin ohne Code‑Rename.

19.7 Was Cline dabei machen kann (und was nicht)
Kann Cline gut

.clinerules, .clineignore, Docs, Scripts verbessern

CI‑Workflow Dateien erstellen

kontrollierte Diff‑Checks, „was würde sich ändern“

Nicht zuverlässig / nicht sinnvoll (für Cline)

GitHub UI Aktionen (Template‑Haken setzen, Repo Settings)

Große automatische „Syncs“ über viele Repos ohne deine Kontrolle

Ergebnis von Punkt 19

Du hast jetzt ein klares Wartungsmodell:

Template wird verbessert und getaggt

Neue Projekte starten sauber

Bestehende Projekte bekommen Updates nur gezielt, über Branch + check.ps1 + Commit

Wenn du willst, kann ich daraus als letzten Bonus noch Punkt 20 machen: „Minimaler Release‑Prozess für das Template“ (Tagging, CHANGELOG.md, und eine kurze Checkliste vor jedem Template‑Release).

ja
Thought for 1m 40s
Punkt 20: Minimaler Release‑Prozess für dein Template (Tags, Changelog, Release‑Checkliste)
Ziel

Du willst Template‑Änderungen nicht „irgendwie“ pushen, sondern in kleinen, nachvollziehbaren Releases veröffentlichen, damit du später weißt:

welche Version du wann hattest,

was sich geändert hat,

ob ein neues Projekt wirklich auf dem erwarteten Stand basiert.

Das ist besonders hilfreich, sobald du mehr als 2–3 Projekte aus der Vorlage erzeugst.

20.1 Dateien einführen: CHANGELOG.md und TEMPLATE_VERSION.txt
TEMPLATE_VERSION.txt

Eine Zeile, z. B.:

0.2


Das ist die maschinenlesbare Version.

CHANGELOG.md

Minimal und praktisch:

# Changelog

## 0.2
- Add bootstrap script for template init (docs/memory + optional venv setup)
- Add GitHub Actions CI quality gate
- Improve template usage documentation

## 0.1
- Initial template: Windows + VS Code + Python + Cline workflow
- scripts/check.ps1 and scripts/fix.ps1
- .clinerules, .clineignore, memory-bank


Warum das reicht:

Du brauchst keine perfekte Release‑Doku – nur „was hat sich geändert“.

20.2 Release‑Checkliste (vor jedem Template‑Release)

Das ist die „Sachrunde“ bevor du taggst:

Working tree clean

git status


Quality Gate grün

.\scripts\check.ps1


Bootstrap Self‑Test (wenn du ihn geändert hast)

lokal kopieren oder GitHub “Use this template” Test (dein Punkt 17/18)

.\scripts\bootstrap.ps1 -SetupVenv -NonInteractive

Docs konsistent

README enthält Template‑Anleitung

TEMPLATE_USAGE/BOOTSTRAP.md aktuell

Memory Bank enthält keine lokalen Pfade

CI grün (wenn vorhanden)

GitHub Actions letzter Run grün

20.3 Version bump (einfaches Schema)

Empfehlung, um es simpel zu halten:

0.1, 0.2, 0.3 … solange du noch viel am Grundgerüst drehst.

Später ggf. 1.0, wenn du „stabil“ bist.

Ablauf:

TEMPLATE_VERSION.txt erhöhen

CHANGELOG.md ergänzen

committen

Beispiel:

git add TEMPLATE_VERSION.txt CHANGELOG.md
git commit -m "chore: release 0.2"

20.4 Tag erstellen und pushen

Tag‑Name (empfohlen):

v0.2-template

Commands:

git tag v0.2-template
git push origin v0.2-template


Optional zusätzlich:

git push

20.5 GitHub Release (optional)

Auf GitHub kannst du aus dem Tag direkt einen Release erzeugen:

Releases → Draft new release → Tag auswählen → kurze Notes aus dem Changelog

Das ist optional, aber nett, weil es die Version sichtbarer macht.

20.6 Bonus: “Welche Template‑Version wurde in einem Projekt benutzt?”

Weil GitHub beim „Use this template“ nicht automatisch „Template Version“ ins neue Repo schreibt, hast du zwei Optionen:

Option A (manuell, simpel)

Nach dem Erstellen eines neuen Projekts:

Du schreibst einmal in memory-bank/projectbrief.md:

„Created from python-cline-template v0.2-template“

Option B (kleiner Bootstrap‑Upgrade, später)

Bootstrap kann am Ende eine Datei schreiben:

TEMPLATE_ORIGIN.txt mit:

Repo‑Name + Datum + Template‑Version

Das ist nice-to-have. Du musst das nicht sofort machen.

Ergebnis von Punkt 20

Du hast einen minimalen, aber professionellen Release‑Prozess:

Versionfile

Changelog

Checkliste

Tags

Damit bleibt dein Template langfristig wartbar und nachvollziehbar.

Wenn du willst, kann ich dir jetzt aus Punkt 13–20 noch eine komprimierte Master‑Liste machen (nur die Titel + 1 Satz je Punkt), die du Cline als „Projektplan“ geben kannst, bevor ihr Punkt für Punkt in Plan/Act geht.

ja
Thought for 54 seconds

Hier ist die komprimierte Master‑Liste (Punkt 13–20), so dass du sie Cline als Gesamtplan geben kannst – und danach arbeitet ihr wirklich Punkt für Punkt ab.

Master‑Liste Punkt 13–20

Punkt 13 – Template‑Repo vorbereiten und entpersonalisieren
Alte Namen/Pfade entfernen, Memory‑Bank als Template formulieren, python-cline-template als Platzhalter einführen, keine .py Änderungen.

 

Punkt 14 – Bootstrap‑Script als Standard integrieren
scripts/bootstrap.ps1 erstellen: Projektname aus Ordnername, nur Textdateien anfassen, Platzhalter ersetzen, optional .venv+Tools+check.ps1.

 

Punkt 15 – GitHub Actions CI hinzufügen
.github/workflows/ci.yml anlegen: Ruff + pytest auf Ubuntu (und optional Windows mit .venv + check.ps1).

 

Punkt 16 – Template‑Doku finalisieren
README‑Block „Use this template“ + kurze Datei TEMPLATE_USAGE.md/BOOTSTRAP.md, ohne lokale Pfade, so dass Bootstrap nichts zerstört.

 

Punkt 17 – Lokaler Self‑Test vor dem Publish
Template in neuen Ordner kopieren (ohne .git/.venv), bootstrap.ps1 laufen lassen (ohne/mit -SetupVenv), prüfen: keine .py Änderungen, check.ps1 grün.

 

Punkt 18 – Manuell auf GitHub veröffentlichen und als Template markieren
Repo python-cline-template publishen, Template‑Haken setzen, End‑to‑End Test über „Use this template“ + clone + bootstrap + commit/push.

 

Punkt 19 – Wartungsmodell für Updates
Template weiterentwickeln, tags/versionieren, Updates in bestehende Projekte nur gezielt (Branch + einzelne Dateien übernehmen + check.ps1).

 

Punkt 20 – Minimaler Release‑Prozess
TEMPLATE_VERSION.txt + CHANGELOG.md, Release‑Checkliste, Tagging (vX.Y-template), optional GitHub Release.

Hinweis für deinen Ablauf mit Cline

Punkt 13–16: Cline kann das gut umsetzen (Docs/Scripts/Workflows).

Punkt 17: ist überwiegend Nutzer‑Arbeit (Kopieren/Simulation), Cline kann nur anleiten.

Punkt 18: GitHub UI ist Nutzer‑Arbeit (Publish/Settings/Template‑Haken).

Punkt 19–20: Cline kann Dateien erstellen (Changelog/Version), aber das Release/Tagging machst du am besten bewusst.